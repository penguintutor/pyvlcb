{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to PyVLCB","text":"<p>PyVLCB is a Python library for VLCB (Versatile Layout Control Bus). It implements the core communication protocols defined by the CBUS\u00ae protocol and includes extensions for the newer VLCB specifications. It also includes a module for the CANUSB4 controller from MERG.</p> <p>PyVLCB project page on PenguinTutor.com</p>"},{"location":"#installation","title":"Installation","text":"<p>Basic install can be performed by downloading the files and running</p> <p>pip install pyvlcb</p> <p>See the README.md for more detailed install details, including how the library can be installed as a submodule within your own software.</p>"},{"location":"#demo-code","title":"Demo code","text":"<p>See the demo directory for simple code examples. </p>"},{"location":"#core-concepts","title":"Core concepts","text":"<p>The library conists of 4 core classes which are imported from pyvlcb</p> <ul> <li>VLCB - core library<ul> <li>Easy to use methods for reading and writing CBUS / VLCB commands</li> </ul> </li> <li>VLCBFormat - VLCB formatting<ul> <li>Converts data packets for sending </li> </ul> </li> <li>VLCBOpcode - Lookup opcode values. <ul> <li>Primarily intended for internal use by the other classes</li> </ul> </li> <li>CanUSB4 - Communicate with the CAN USB 4 controller<ul> <li>Uses pyserial for communication with the Merg CAN USB 4</li> <li>Can accept packets created using the VLCB core library</li> </ul> </li> </ul> <p>Initially connection is made to CanUSB4 to establish a connection with the hardware. For most uses sending a command is performed by calling the appropriate VLCB method to generate a command string. Then passing that command string to the CanUSB4 send_data method. Data from the bus is read using read_usb which can then be passed to the VLCB parse_input method. Additional methods are available to extract the relevant information from the parse_input response.</p>"},{"location":"#additional-documentation","title":"Additional documentation","text":"<p>For further details please see PenguinTutor PyVLCB page</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Simplified methods for CBUS / VLCB lookup</li> <li>Full CBUS opcode support</li> <li>Fully type-hinted for better IDE support</li> <li>Full opcode listing for CBUS and VLCB</li> </ul>"},{"location":"#legal-and-trademarks","title":"Legal and Trademarks","text":"<ul> <li>CBUS\u00ae is a registered trademark of Dr. Michael Bolton.</li> <li>This library is an independent implementation based on publicly available protocol documentation and is not officially affiliated with or endorsed by the trademark holder.</li> <li>All other trademarks are the property of their respective owners.</li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>Handle VLCB formatting</p> <p>It generates the appropriate strings which can be sent to CBUS / VLCB</p> <p>Attributes:</p> Name Type Description <code>can_id</code> <p>The Can ID for your software (default = 60)</p> Source code in <code>src/pyvlcb/__init__.py</code> <pre><code>class VLCB:\n    \"\"\"Handle VLCB formatting\n\n    It generates the appropriate strings which can be sent to CBUS / VLCB\n\n    Attributes:\n        can_id: The Can ID for your software (default = 60)\n\n    \"\"\"\n    # 60 is default canid for canusb4 (127 is dcc controller)\n    def __init__ (self, can_id: Optional[int] = 60) -&gt; None:\n        \"\"\"Inits VLCB with a can_id\n\n        Args:\n            can_id: The can_id for the software (default = 60)\n        \"\"\"\n        self.can_id = can_id\n        self.debug = False\n\n    # Takes input bytestring and parses header / data\n    # Does not try and interpret op-code - that is left to VLCB_format\n    def parse_input(self, input_bytes: bytes) -&gt; VLCBFormat:\n        \"\"\"Parse a raw CBUS packet as an input bytestring\n\n        Take a bytestring (or string) from the CBUS and extract the details\n\n        Args: \n            input_types (bytestring): Input raw bytestring (or string)\n\n        Returns:\n            VLCBFormat: parsed data in VLCBFormat\n\n        Raises:\n            ValueError: If invalid data string\n\n        \"\"\"\n        # Also allow string (no need to decode)\n        if isinstance (input_bytes, str):\n            input_string = input_bytes\n        else:\n            input_string = input_bytes.decode(\"utf-8\")\n        if (len(input_string) &lt; 5):        # packets are actually much longer\n            raise ValueError(f\"input_bytes '{input_string}' is too short.\")\n        if (input_string[0] != \":\"):\n            raise ValueError(f\"No start frame in '{input_string}'\")\n        if (input_string[1] != \"S\"):\n            raise ValueError(\"Format not supported - only Standard frames allowed in {input_string}\")\n        # Use try when converting to number in case of error\n        try:\n            header = input_string[2:6]\n            header_val = int(header, 16)\n        except:\n            raise ValueError(f\"Invalid format, number expected {header}\")\n            header_val = 0\n        logger.debug (f\"Header {hex(header_val)}\")\n        priority = (header_val &amp; 0xf000) &gt;&gt; 12\n        logger.debug (f\"Priority {priority:b}\")\n        can_id = (header_val &amp; 0xfe0) &gt;&gt; 5\n        logger.debug(f\"Can ID {can_id}\")\n        # Next is N / RTR can be ignored\n        logger.debug(f\"N / RTR {input_string[6]}\")\n        # Data is rest excluding ; \n        data = input_string[7:-1]\n        logger.debug(f\"Data {data}\")\n        # Creates a VLCB_format and returns that\n        return VLCBFormat (priority, can_id, data)\n\n    # Parse and format into standard log format (datastring, direction, fulldata, direction, can_id, op_code, data\n    # For log all values are returned as strings - note that the number (log entry number) is not returned\n    def log_entry(self, input_string: str) -&gt; list[str]:\n        \"\"\"Parse a log entry and return as a list of string values\n\n        Args:\n            input_string (string): String consisting of of num, date, direction, message as a single string\n\n        Returns (list[str]): List of strings\n\n        \"\"\"\n        # First remove number and date from the front of the string\n        entry_parts = input_string.split(',', 3)\n        date_string = entry_parts[1]\n        direction = entry_parts[2]\n        message = entry_parts[3]\n        vlcb_entry = self.parse_input (message)\n        # Error handling of invalid packet\n        if vlcb_entry == False:\n            return [message, \"??\", \"\", \"Invalid data\"]\n        # convert op-code to string\n        # opcode is first two chars of data\n        opcode = vlcb_entry.data[0:2]\n        opcode_string = f'{opcode} - {VLCBOpcode.opcode_mnemonic(opcode)}'\n        #data_string = f\"{VLCBOpcode.parse_data(vlcb_entry.data)}\"\n        data_string = dict_to_string(VLCBOpcode.parse_data(vlcb_entry.data))\n        return [date_string, direction, message, str(vlcb_entry.can_id), opcode_string, data_string]\n        # Todo - error handling \n\n\n    # Static Methods moved to utils\n    #num_to_1hexstr = staticmethod(num_to_1hexstr)\n    #num_to_2hexstr = staticmethod(num_to_2hexstr)\n    #num_to_4hexstr = staticmethod(num_to_4hexstr)\n\n\n    # Create header using low priority and can_id (or self.can_id)\n    # If opcode provided, but no priority then appropriate min code looked up\n    # MajPri would be based on packet aging - needs to be managed outside of this\n    def make_header(self, \n                majpri: int = 0b10, \n                minpri: Optional[int] = None, \n                can_id: Optional[int] = None, \n                opcode: Optional[int] = None) -&gt; str:\n        \"\"\"Create a CBUS/VLCB header\n\n        Args:\n            byte1 (byte): Most significant byte\n            byte2 (byte): Least significant byte\n\n        Returns:\n            String: A hex representation of the number\n        \"\"\"\n        if can_id == None:\n            can_id = self.can_id\n\n        if minpri == None and opcode != None:\n            minpri = VLCBOpcode.opcode_priority(opcode)\n\n        # If opcode not updated then use default low priority\n        # Lower number is higher priority\n        if minpri == None:\n            minpri = 0b11\n\n        header_val = (majpri &lt;&lt; 14) + (minpri &lt;&lt; 12) + (can_id &lt;&lt; 5)\n        header_to_hex = (\"000\" + hex(header_val).upper()[2:])[-4:]\n        header_string = f':S{header_to_hex}N'\n        return header_string\n        #return header_string.encode('utf-8')\n\n\n    # Discover nodes\n    def discover (self) -&gt; str:\n        \"\"\"Create a discovery string \n\n        Uses op-code QNN (0D)\n\n        Returns:\n            String: A string for the request\n        \"\"\"\n        # Return QNN \n        return self.make_header(opcode='0D') + '0D;'\n\n    # Discover number of events configured\n    def discover_evn (self, node_id: int) -&gt; str:\n        \"\"\"Create a discover number of events for a node\n\n        Uses op-code RQEVN (58)\n\n        Args:\n            node_id (int): Node ID to query\n\n        Returns:\n            String: A string for the request\n        \"\"\"\n        return f\"{self.make_header(opcode='58')}58{num_to_2hexstr(node_id)};\" \n\n    # Discover number of events available\n    def discover_nevn (self, node_id: int) -&gt; str:\n        \"\"\"Create a discover number of events available for a node\n\n        Uses op-code NNEVN (56)\n\n        Args:\n            node_id (int): Node ID to query\n\n        Returns:\n            String: A string for the request\n        \"\"\"\n        return f\"{self.make_header(opcode='56')}56{num_to_2hexstr(node_id)};\"\n\n    # Discover stored events NERD\n    def discover_nerd (self, node_id: int) -&gt; str:\n        \"\"\"Create a discover stored events for a node\n\n        Uses op-code NERD (57)\n\n        Args:\n            node_id (int): Node ID to query\n\n        Returns:\n            String: A string for the request\n        \"\"\"\n        return f\"{self.make_header(opcode='57')}57{num_to_2hexstr(node_id)};\"\n\n    # Emergency stop all locos\n    # RESTP\n    def loco_stop_all (self) -&gt; str:\n        \"\"\"Create an emergency stop all locos\n\n        Uses op-code RESTP (0A)\n\n        Returns:\n            String: A string for the request\n        \"\"\"\n        return f\"{self.make_header(opcode='0A')}0A;\"\n\n    # node and ev should be the IDs - state either \"on\" or \"off\" / True or False\n    def accessory_command (self, node_id: int, ev_id: int, state: Union[str, bool]) -&gt; str:\n        \"\"\"Create an accessory command\n\n        Uses appropriate Accessory On / Off command\n        Defaulting to short, but using long if &gt; 0xffff\n\n        Args:\n            node_id: Node ID to query\n            ev_id: Event ID\n            state: State to change to can be \"on\" or \"off\" / True or False\n\n        Returns:\n            String: A string for the request\n        \"\"\"\n        # if ev_id is a string then convert to an int\n        # Setting based to 0 will automatically handle base 10 or hex\n        ev_id = int(ev_id, 0)\n        # determine if long or short\n        if ev_id &lt;= 0xffff:\n            return self.accessory_short_command (node_id, ev_id, state)\n        else:\n            return self.accessory_long_command (node_id, ev_id, state)\n\n    # Note that short is the same as long but different code and node_id is added (already included in long)\n    def accessory_short_command (self, node_id: int, ev_id: int, state: Union[str, bool]) -&gt; str:\n        \"\"\"Create an accessory short command\n\n        Uses ASON (98) or ASOF (99)\n\n        Args:\n            node_id: Node ID to query\n            ev_id: Event ID\n            state: State to change to can be \"on\" or \"off\" / True or False\n\n        Returns:\n            String: A string for the request\n        \"\"\"\n        # Turn on\n        if state == True or state == \"on\":\n            # ASON\n            return f\"{self.make_header(opcode='98')}98{num_to_2hexstr(node_id)}{num_to_2hexstr(ev_id)};\"\n        # Turn off = ASOFF\n        else:\n            return f\"{self.make_header(opcode='99')}99{num_to_2hexstr(node_id)}{num_to_2hexstr(ev_id)};\"\n\n    def accessory_long_command (self, node_id: int, ev_id: int, state: Union[str, bool]) -&gt; str:\n        \"\"\"Create an accessory long command\n\n        Uses ACON (90) or ACOF (91)\n\n        Args:\n            node_id: Node ID to query\n            ev_id: Event ID\n            state: State to change to can be \"on\" or \"off\" / True or False\n\n        Returns:\n            String: A string for the request\n        \"\"\"\n        # Turn on\n        if state == True or state == \"on\":\n            # ASON\n            return f\"{self.make_header(opcode='90')}90{num_to_4hexstr(ev_id)};\"\n        # Turn off = ASOFF\n        else:\n            return f\"{self.make_header(opcode='91')}91{num_to_4hexstr(ev_id)};\"\n\n    # RLOC (Allocate loco) :SB040N40D446;\n    # Short address upper address all zeros, only 6 bits of the lower byte are used (1 to 127) 0 is decoderless\n    # :SB040N40D446 D446 becomes 5190(10) = 1446(H) + C000 (highest 2 bits set by CAB - indicate long mode)\n\n    # Generate code to allocate a loco\n    # Assume long code, but if long = False and ID &lt; 128 then use short mode\n    def allocate_loco (self, loco_id: int, long: Optional[bool] = True) -&gt; str:\n        \"\"\"Create an allocate loco request\n\n        Uses RLOC (40)\n\n        Args:\n            loco_id: Loco ID (long or short number)\n            long: Long loco ID (True) or short loco ID (False)\n\n        Returns:\n            String: A string for the request\n        \"\"\"\n        # Generate RLOC to allocate loco to a session\n        if long == False and loco_id &gt;= 127:\n            raise ValueError (\"Invalid short code. Loco ID {loco_id} is larger than 127\")\n        if long == True:\n            loco_id = loco_id | 0xC000\n        return f\"{self.make_header(opcode='40')}40{num_to_2hexstr(loco_id)};\"\n\n    def release_loco (self, session_id: int) -&gt; str:\n        \"\"\"Create a release loco request\n\n        Uses KLOC (21)\n\n        Args:\n            session_id: Session number\n\n        Returns:\n            String: A string for the request\n        \"\"\"\n        return f\"{self.make_header(opcode='21')}21{num_to_1hexstr(session_id)};\"\n\n    def steal_loco (self, loco_id: int, long: Optional[bool] = True) -&gt; str:\n        \"\"\"Create an steal loco request\n\n        Takes the loco and other connectons to the loco should be terminated.        \n        Uses GLOC (60)\n\n        Args:\n            loco_id: Loco ID (long or short number)\n            long: Long loco ID (True) or short loco ID (False)\n\n        Returns:\n            String: A string for the request\n\n        Raises:\n            InvalidLocoError\n        \"\"\"\n        # GLOC 61 - flag = 1 for steal, flag = for share\n        if long == False and loco_id &gt;= 127:\n            raise InvalidLocoError(f\"Invalid short code {loco_id}\")\n        if long == True:\n            loco_id = loco_id | 0xC000\n        return f\"{self.make_header(opcode='61')}61{num_to_2hexstr(loco_id)}01;\"   \n\n    def share_loco (self, loco_id: int, long: Optional[bool] = True) -&gt; str:\n        \"\"\"Create an share loco request\n\n        Takes the loco and other connectons to the loco can remain.\n        Uses GLOC (61)\n\n        Args:\n            loco_id: Loco ID (long or short number)\n            long: Long loco ID (True) or short loco ID (False)\n\n        Returns:\n            String: A string for the request\n\n        Raises:\n            InvalidLocoError\n        \"\"\"\n        # GLOC 61 - flag = 1 for steal, flag = for share\n        if long == False and loco_id &gt;= 127:\n            raise InvalidLocoError(f\"Invalid short code {loco_id}\")\n        if long == True:\n            loco_id = loco_id | 0xC000\n        return f\"{self.make_header(opcode='61')}61{num_to_2hexstr(loco_id)}02;\" \n\n    def keep_alive (self, session_id: int) -&gt; str:\n        \"\"\"Create an keep alive request\n\n        For any loco allocated send a keep alive at least every 4 seconds\n        Uses DKEEP (23)\n\n        Args:\n            session_id: Session ID \n\n        Returns:\n            String: A string for the request\n        \"\"\"\n        return f\"{self.make_header(opcode='23')}23{num_to_1hexstr(session_id)};\"\n\n    def loco_speed_dir (self, session_id: int, speed: int, direction: int) -&gt; str:\n        \"\"\"Set loco speed and direction based on separate arguments\n\n        Same as loco_speeddir but this takes 2 arguments, whereas loco_speeddir needs a combined value\n        Maximum call this once every 32 milliseconds\n\n        Uses DSPD (47)\n\n        Args:\n            session_id: Session ID\n            speed: 0 to 127 (1 is increased to 2 to avoid emergency stop)\n            direction: 1 = forward, 0 = reverse\n\n        Returns:\n            String: A string for the request\n\n        Raises:\n            ValueError is speed is out of range, or invalid direction\n        \"\"\"\n        if speed &lt; 0 or speed &gt; 127:\n            raise ValueError (\"Invalid speed specified. Must be in range 0 to 127\")\n        if direction &lt;0 or direction &gt; 1:\n            raise ValueError (\"Direction is not valid. Use 1 for forward, 0 for reverse\")\n        # special case - ignore emergency stop\n        if speed == 1:\n            speed = 2\n        speeddir = (direction * 0x80) + speed\n        return self.loco_speeddir (session_id, speeddir)\n\n    # Set loco speed and direction (always done together)\n    def loco_speeddir (self, session_id: int, speeddir: int) -&gt; str:\n        \"\"\"Set loco speed and direction\n\n        Maximum call this once every 32 milliseconds\n        Needs combined speed and direction value.\n        If speed is set to 1 then that is considered an emergency stop\n\n        Uses DSPD (47)\n\n        Args:\n            session_id: Session ID\n            speeddir: Unsigned 8 bit number. MSB is direction, 7 bits for speed\n\n        Returns:\n            String: A string for the request\n        \"\"\"\n        return f\"{self.make_header(opcode='47')}47{num_to_1hexstr(session_id)}{num_to_1hexstr(speeddir)};\"\n\n    # Set function using DFUN - needs to be provided with the two bytes\n    # First byte is group (1 = F1 to F4, 2 = F5 to F8, 3 = F9 to F12)\n    # 4 = F13 to 19, 5 = F20 to F28\n    # Second byte is 1 bit per function - set 1 for on, 0 for off, lsb to right\n    # eg. 1 = 0001, 2 = 0010\n    def loco_set_dfun (self, session_id: int, byte1: bytes, byte2: bytes) -&gt; str:\n        \"\"\"Create a set function request\n\n        Uses DFUN (60)\n\n        Args:\n            session_id: Session ID\n            byte1: Function group. 1 = F1 to F4, 2 = F5 to F8, 3 = F9 to F12, 4 = F13 to 19, 5 = F20 to F28\n            byte2: 1 bit per function 1=on, 0=off. LSB to right eg 1 = 0001, 2 = 0010\n\n        Returns:\n            String: A string for the request\n        \"\"\"\n        return f\"{self.make_header(opcode='60')}60{num_to_1hexstr(session_id)}{num_to_1hexstr(byte1)}{num_to_1hexstr(byte2)};\"\n\n    def loco_set_function (self, session_id: int, function_num, function_list) -&gt; str:\n        \"\"\"Create a set function request using the function list\n        Sends the entire group of functions where the function_num resides\n        This is an alternative to loco_set_dfun as this calculates the bytes\n        this method can only be used for functions 0 to 27\n\n        Uses DFUN (60)\n\n        Args:\n            session_id: Session ID\n            byte1: Function number\n            byte2: List of current function statuses\n\n        Returns:\n            String: A string for the request\n\n        Raises:\n            ValueError: Typically raised from f_to_bytes\n        \"\"\"\n        byte1_2 = f_to_bytes(function_num, function_list)\n        return f\"{self.make_header(opcode='60')}60{num_to_1hexstr(session_id)}{byte1_2[0]}{byte1_2[1]};\"\n</code></pre> <p>Handle USB serial communication to CANUSB4</p> <p>Uses pyserial to communicate over USB.</p> <p>Attributes:</p> Name Type Description <code>port</code> <p>The usb port eg. /dev/ttyACM0 (RPi)</p> Source code in <code>src/pyvlcb/canusb.py</code> <pre><code>class CanUSB4 ():\n    \"\"\"Handle USB serial communication to CANUSB4\n\n    Uses pyserial to communicate over USB.\n\n    Attributes:\n        port: The usb port eg. /dev/ttyACM0 (RPi)\n    \"\"\"\n    def __init__ (self, \n                  port: str, \n                  baud: Optional[int] = 115200, \n                  timeout: Optional[float] = 0.01,\n                  exclusive: Optional[bool] = True) -&gt; None:\n        \"\"\"Inits CanUSB4 with a USB port\n\n        Args:\n            port: USB port eg. /dev/ttyACM0 (RPi)\n            baud: Baud rate in bytes\n            timeout: How long to wait for a serial timeout (seconds)\n\n        Raises:\n            DeviceConnectionError: If the port cannot be opened or is already in use.\n            InvalidConfigurationError: If the port name is empty or invalid.\n\n        \"\"\"\n        self.debug = False\n        self.port = port\n        self.baud = baud\n        self.timeout = timeout\n        self.max_retry = 30    # How many times to attempt on get_data must be at least as long as frame\n        # Timeout for a request could be max_rety x timeout\n        self.exclusive = exclusive\t# Exclusive determines if check for exclusive use of the USB port\n        # If this is set to false then if another application is already using the port then the application\n        # will run, but appear to hang if there is no response because another thread has already\n        # taken the incoming data\n\n        if not port:\n            raise InvalidConfigurationError(\"Port name cannot be empty\")\n\n        # buffer to hold partial string - allows us to continue if read ends partway through a packet\n        self.current_buffer = ''\n        # Track if we are in a valid string (ie. ignore any data outside of : ; blocks\n        self.data_start = False\n        self.connect()\n\n\n    # Optional arguments override existing\n    def connect(self,\n                port: Optional[str] = None,\n                baud: Optional[int] = None,\n                timeout: Optional[float] = None,\n                exclusive: Optional[bool] = None) -&gt; None:\n        \"\"\"Inits CanUSB4 with a USB port\n\n        Args:\n            port: USB port eg. /dev/ttyACM0 (RPi)\n            baud: Baud rate in bytes\n            timeout: How long to wait for a serial timeout (seconds)\n\n        Raises:\n            DeviceConnectionError: If the port cannot be opened or is already in use.\n            InvalidConfigurationError: If the port name is empty or invalid.\n\n        \"\"\"\n        if port != None:\n            self.port = port\n        if not self.port:\n            raise InvalidConfigurationError(\"Port name cannot be empty\")\n        if baud != None:\n            self.baud = baud\n        if timeout != None:\n            self.timeout = timeout\n        if exclusive != None:\n            self.exclusive = exclusive\n        try:\n            self.ser = serial.Serial(\n                self.port,\n                self.baud,\n                timeout=self.timeout,\n                exclusive = exclusive\n                )\n        except serial.SerialException as e:\n            raise DeviceConnectionError(f\"Could not open port {self.port}\") from e\n        if self.ser:\n            logger.info(\"Connected to serial port\")\n\n\n    # Data can either be string or bytestring\n    def send_data(self, data: Union[str, bytes]) -&gt; None:\n        \"\"\"Send data to serial\n\n        Args:\n            data: Data to send, normally from a VLCB method\n\n        Raises:\n            InvalidConfigurationError: If string contains invalid characters\n            TypeError: If data passed is not a string or a bytestring\n            DeviceConnectionError: Error sending data - possible connection lost\n        \"\"\"\n        logger.debug(f\"Sending {data}\")\n        if isinstance(data, str):\n            try:\n                # Convert string to bytes\n                payload = data.encode('ascii') # using ascii which is more restrictive than default \"utf-8\"\n            except UnicodeEncodeError as e:\n                raise InvalidConfigurationError(f\"String contains invalid characters: {data}\") from e\n        elif isinstance(data, bytes):\n            # It's already bytes, just use it\n            payload = data\n        else:\n            # User sent an int, list, or something else weird\n            raise TypeError(f\"Expected str or bytes, got {type(data).__name__}\")\n\n        # Send payload which is now bytes\n        try:\n            self.ser.write(payload)\n        except serial.SerialException as e:\n            raise DeviceConnectionError(\"Connection lost during write\") from e\n\n    def read_data(self) -&gt; List[str]:\n        \"\"\"Read data from CanUSB4\n\n        Returns:\n            List: List of strings for all data read\n\n        Raises:\n            DeviceConnectionError: Error receiving data - possible connection list\n\n\n        \"\"\"\n\n        num_bytes = self.ser.in_waiting\n        # As each data string is read then it is stored into this list\n        # Which allows all new packets to be returned\n        received_data = []\n        if num_bytes &gt; 1:\n            try:\n                in_chars = self.ser.read(num_bytes)\n            except serial.SerialException as e:\n                raise DeviceConnectionError(\"Connection lost during read\") from e\n            # Unable to communicate with USB\n            # Any other error\n            except Exception as e:\n                raise DeviceConnectionError(\"Unable to read other error\") from e\n\n\n            for i in range(0, len(in_chars)):\n                this_char = chr(in_chars[i])\n                # End of packet\n                if this_char == ';':\n                    # Check we have some data if not then ignore\n                    if len(self.current_buffer) == 0:\n                        continue\n                    # Add the terminating char\n                    self.current_buffer += this_char\n                    logger.debug (f\"Read {self.current_buffer}\")\n                    received_data.append(self.current_buffer)\n                    # delete the data\n                    self.current_buffer = ''\n                    # no longer inside a data packet\n                    self.data_start = False\n                # Start of packet (resets string even if previous data)\n                elif this_char == ':':\n                    self.data_start = True\n                    self.current_buffer = ':'\n                # Only add character if we are inside a data block\n                elif self.data_start == True:\n                    self.current_buffer += this_char\n                # If not then we are not in data block\n                else:\n                    continue\n        return received_data    \n</code></pre> <p>Handles a single VLCB packet</p> <p>Attributes:</p> Name Type Description <code>priority</code> <p>CAN priority</p> <code>can_id</code> <p>CAN ID</p> <code>data</code> <p>Remaining data as a hex str</p> Source code in <code>src/pyvlcb/vlcbformat.py</code> <pre><code>class VLCBFormat :\n    \"\"\" Handles a single VLCB packet\n\n    Attributes:\n        priority: CAN priority\n        can_id: CAN ID\n        data: Remaining data as a hex str\n\n    \"\"\" \n\n    def __init__ (self, priority: int, can_id: int, data: str) -&gt; None:\n        \"\"\"Inits VLCBformat\n\n        Args:\n            priority: CAN priority\n            can_id: CAN ID\n            data: Remaining data as a hex string\n\n        \"\"\"\n        self.priority = priority # Priority is actually high and low priority (2bit high / 2bit low) but just treated as single value\n        self.can_id = can_id\n        self.data = data # Data is left as hex string\n\n    # Lookup OpCode\n    def opcode (self): # -&gt; Dict[str,str]:\n        \"\"\"Returns the opcode associated with the data string\n\n        Returns:\n            Dictionary of the opcode data\n\n        Raises:\n            ValueError: If opcode not found\n        \"\"\"\n        str_value = self.data[0:2]\n        if str_value in VLCBOpcode.opcodes.keys():\n            return VLCBOpcode.opcodes[str_value]['opc']\n        else:\n            raise ValueError(f\"Opcode {str_value} is not defined.\")\n\n    def get_data (self) -&gt; OpcodeData:\n        \"\"\"Returns the opcode associated with the data string as a dict\n\n        Returns:\n            OpcodeData: Dict from the VLCBOpcode\n\n        Raises:\n            ValueError: If opcode not found\n        \"\"\"\n        return VLCBOpcode.parse_data(self.data)\n\n    def format_data (self) -&gt; OpcodeData:\n        \"\"\"Returns the opcode associated with the data string\n\n        Returns:\n            OpcodeData: Dict from the VLCBOpcode\n\n        Raises:\n            ValueError: If opcode not found\n        \"\"\"\n        return VLCBOpcode.parse_data(self.data)\n\n    def get_loco_id (self) -&gt; int:\n        \"\"\"Converts AddrHigh and AddrLow into a loco_id\n\n        Only valid with certain VLCBFormat packets associated with Locos.\n        If packet is does not contain the AddrHigh &amp; AddrLow values (which\n        may be formatted differently) then raises a InvalidLocoError\n\n        Returns:\n            loco_id: Loco number\n\n        Raises:\n            InvalidLocoError: If AddrHigh / AddrLow are not in the packet\n        \"\"\"\n        loco_id = None\n        if self.opcode() == \"PLOC\":\n            # Get data\n            data_dict = VLCBOpcode.parse_data(self.data)\n            loco_id = data_dict['AddrHigh_AddrLow'] &amp; 0x3FFF\n        elif self.opcode() == \"ERR\":\n            # also check it's one of the Error codes associated with allocate loco etc.\n            # 1 = loco stack full 2 = loco taken, 7 = invalid request\n            # The following are not supported as data bytes contain session / consist ID and not loco_id\n            # 3 = no session, 4 consist empty, 5 loco not found, 6 can bus error\n            data_dict = VLCBOpcode.parse_data(self.data)\n            if data_dict[\"ErrCode\"] in [1, 2, 7]:\n                loco_id = bytes_to_addr(data_dict['Byte1'],data_dict['Byte2']) &amp; 0x3FFF\n            else:\n                raise InvalidLocoError (f\"Error code {data_dict['ErrCode']} does not contain a loco_id\")\n\n        # If loco_id not updated then raise error\n        if loco_id != None:\n            return loco_id\n        else:\n            raise InvalidLocoError(f\"Opcode {self.opcode()} does not contain a loco_id\")\n\n    def get_function_list (self) -&gt; List[int]:\n        \"\"\"Where packet contains Fn1, Fn2, Fn3 (eg. PLOC)\n        returns \n\n        Only valid with certain VLCBFormat packets associated with Locos.\n        If packet is does not contain the 3 byte values (which\n        may be formatted differently) then raises a InvalidFunctionError\n\n        Returns:\n            List of function values as 0 or 1 for each function as off and on\n\n        Raises:\n            InvalidFunctionError: If Function Bytes are not in the packet\n        \"\"\"\n        if self.opcode() == \"PLOC\":\n            # Get data\n            data_dict = VLCBOpcode.parse_data(self.data)\n            return bytes_to_functions (data_dict['Fn1'], data_dict['Fn2'], data_dict['Fn3'])\n        else:\n            raise InvalidLocoError(f\"Opcode {self.opcode()} does not contain a loco_id\")\n\n\n\n\n    def __str__ (self):\n        return f'{self.priority} : {self.can_id} : {self.opcode()} ({self.data[0:2]}) : {self.data} / {self.format_data()}'\n</code></pre> <p>List of opcodes and other related data</p> <p>Includes format information and user friendly strings</p> <p>Attributes:</p> Name Type Description <code>opcodes</code> <p>Dict of opcodes indexed by opcode number as a hex string</p> <code>field_formats</code> <p>Dict of data type and number of characters for each field</p> <code>accessory_codes</code> <p>Dict of accessory on and off codes</p> Source code in <code>src/pyvlcb/vlcbformat.py</code> <pre><code>class VLCBOpcode:\n    \"\"\"List of opcodes and other related data\n\n    Includes format information and user friendly strings\n\n    Attributes:\n        opcodes: Dict of opcodes indexed by opcode number as a hex string\n        field_formats: Dict of data type and number of characters for each field\n        accessory_codes: Dict of accessory on and off codes\n\n    \"\"\"\n    # Dict from opcode to dict of opcode information\n    opcodes = {\n        '00':  {'opc': 'ACK', 'title': 'General Acknowledgement', 'format': '', 'minpri': 2, 'comment': 'Positive response to query/request performed for report of availability online'},\n        '01':  {'opc': 'NAK', 'title': 'General No Ack', 'format': '', 'minpri': 2, 'comment': 'Negative response to query/request denied'},\n        '02':  {'opc': 'HLT', 'title': 'Bus Halt', 'format': '', 'minpri': 0, 'comment': 'Commonly broadcasted to all nodes to indicate CBUS is not available and no further packets should be sent until a BON or ARST is received'},\n        '03':  {'opc': 'BON', 'title': 'Bus On', 'format': '', 'minpri': 1, 'comment': 'Commonly broadcasted to all nodes to indicate CBUS is available following a HLT.'},\n        '04':  {'opc': 'TOF', 'title': 'Track Off', 'format': '', 'minpri': 1, 'comment': 'Commonly broadcasted to all nodes by a command station to indicate track power is off and no further command packets should be sent, except inquiries..'},\n        '05':  {'opc': 'TON', 'title': 'Track On', 'format': '', 'minpri': 1, 'comment': 'Commonly broadcasted to all nodes by a command station to indicate track power is on.'},\n        '06':  {'opc': 'ERSTOP', 'title': 'Emergency Stop', 'format': '', 'minpri': 1, 'comment': 'Commonly broadcase to all nodes by a command station to indicate all engines have been emergency stopped.'},\n        '07':  {'opc': 'ARST', 'title': 'System Reset', 'format': '', 'minpri': 0, 'comment': 'Commonly broadcasted to all nodes to indicate a full system reset.'},\n        '08':  {'opc': 'RTOF', 'title': 'Request Track Off', 'format': '', 'minpri': 1, 'comment': 'Sent to request change of track power to off.'},\n        '09':  {'opc': 'RTON', 'title': 'Request Track On', 'format': '', 'minpri': 1, 'comment': 'Sent to request change of track power to on.'},\n        '0A':  {'opc': 'RESTP', 'title': 'Request Emergency Stop All', 'format': '', 'minpri': 0, 'comment': 'Sent to request an emergency stop to all trains . Does not affect accessory control.'},\n        '0C':  {'opc': 'RSTAT', 'title': 'Request Command Station Status', 'format': '', 'minpri': 2, 'comment': 'Sent to query the status of the command station. See description of (STAT) for the response from the command station.'},\n        '0D':  {'opc': 'QNN', 'title': 'Query node number', 'format': '', 'minpri': 3, 'comment': 'Sent by a node to elicit a PNN reply from each node on the bus that has a node number. See OpCode 0xB6'},\n        '10':  {'opc': 'RQNP', 'title': 'Request node parameters', 'format': '', 'minpri': 3, 'comment': 'Sent to a node while in ?setup?mode to read its parameter set. Used when initially configuring a node.'},\n        '11':  {'opc': 'RQMN', 'title': 'Request module name', 'format': '', 'minpri': 2, 'comment': 'Sent by a node to request the name of the type of module that is in setup mode. The module in setup mode will reply with opcode NAME. See OpCode 0xE2'},\n        # Session is the engine session number as HEX byte.\n        '21':  {'opc': 'KLOC', 'title': 'Release Engine', 'format': 'Session', 'minpri': 2, 'comment': 'Sent by a CAB to the Command Station. The engine with that Session number is removed from the active engine list.'},\n        '22':  {'opc': 'QLOC', 'title': 'Query Engine', 'format': 'Session', 'minpri': 2, 'comment': 'The command station responds with PLOC if the session is assigned. Otherwise responds with ERR: engine not found.'},\n        '23':  {'opc': 'DKEEP', 'title': 'Session keep alive', 'format': 'Session', 'minpri': 2, 'comment': 'The cab sends a keep alive at regular intervals for the active session. The interval between keep alive messages must be less than the session timeout implemented by the command station.'},\n        '30':  {'opc': 'DBG1', 'title': 'Debug with one data byte', 'format': 'Status', 'minpri': 2, 'comment': '&lt;Dat1&gt; is a freeform status byte for debugging during CBUS module development. Not used during normal operation'},\n        '3F':  {'opc': 'EXTC', 'title': 'Extended op-code with no additional bytes', 'format': 'ExtOpc', 'minpri': 3, 'comment': 'Used if the basic set of 32 OPCs is not enough. Allows an additional 256 OPCs'},\n        #AddrHigh_AddrLow = Address of the decoder - 7 bit addresses have (AddrH=0). 14 bit addresses have bits 6,7 of AddrH set to 1.\n        '40':  {'opc': 'RLOC', 'title': 'Request engine session', 'format': 'AddrHigh_AddrLow', 'minpri': 2, 'comment': 'The command station responds with (PLOC) if engine is free and is being assigned. Otherwise responds with (ERR): engine in use or (ERR:) stack full. This command is typically sent by a cab to the command station following a change of the controlled decoder address. RLOC is exactly equivalent to GLOC with all flag bits set to zero, but command stations must continue to support RLOC for backwards compatibility.'},\n        # Consist = Consist address\n        # Index = Engine index of the consist\n        '41':  {'opc': 'QCON', 'title': 'Query Consist', 'format': 'Consist,Index', 'minpri': 2, 'comment': 'Allows enumeration of a consist. Command station responds with PLOC if an engine exists at the specified index, otherwise responds with ERR: no more engines'},\n        # NNHigh = high byte of the node number\n        # NNLow = low byte of the node number\n        '42':  {'opc': 'SNN', 'title': 'Set Node Number', 'format': 'NN', 'minpri': 3, 'comment': 'Sent by a configuration tool to assign a node number to a requesting node in response to a RQNN message. The target node must be in ?setup? mode.'},\n        # AllocCode = specific allocation code (1 byte)\n        '43':  {'opc': 'ALOC', 'title': 'Allocate loco to activity', 'format': 'Session,AllocCode', 'minpri': 2, 'comment': ''},\n        '44':  {'opc': 'STMOD', 'title': 'Set CAB session mode', 'format': 'Session,Mode', 'minpri': 2, 'comment': 'MMMMMMMM = mode bits: 0 ? 1: speed mode; 00 ? 128 speed steps; 01 ? 14 speed steps; 10 ? 28 speed steps with interleave steps; 11 ? 28 speed steps; 2: service mode; 3: sound control mode'},\n        # Consist is consist address (8 bits)\n        '45':  {'opc': 'PCON', 'title': 'Consist Engine', 'format': 'Session,Consist', 'minpri': 2, 'comment': 'Adds a decoder to a consist. Dat2 has bit 7 set if consist direction is reversed.'},\n        '46':  {'opc': 'KCON', 'title': 'Remove Engine from consist', 'format': 'Session,Consist', 'minpri': 2, 'comment': 'Removes a loco from a consist.'},\n        # SpeedDir = Speed/dir value. Most significant bit is direction and 7 bits are unsigned speed value. \n        '47':  {'opc': 'DSPD', 'title': 'Set Engine Speed/Dir', 'format': 'Session,SpeedDir', 'minpri': 0, 'comment': 'the unsigned speed value. Sent by a CAB or equivalent to request an engine speed/dir change.'},\n        # SpeedFlag - Is speed flags\n        '48':  {'opc': 'DFLG', 'title': 'Set Engine Flags', 'format': 'Session,SpeedFlag', 'minpri': 2, 'comment': 'Bits 0-1: Speed Mode 00 ? 128 speed steps; 01 ? 14 speed steps; 10 ? 28 speed steps with interleave steps; 11 ? 28 speed steps Bit 2: Lights On/OFF; Bit 3: Engine relative direction; Bits 4-5: Engine state (active =0 , consisted =1, consist master=2, inactive=3) Bits 6-7: Reserved.; Sent by a cab to notify the command station of a change in engine flags.'},\n        # Fnum = Function number, 0 to 27\n        '49':  {'opc': 'DFNON', 'title': 'Set Engine function on', 'format': 'Session,Fnum', 'minpri': 2, 'comment': 'Sent by a cab to turn on a specific loco function. This provides an alternative method to DFUN for controlling loco functions. A command station must implement both methods.'},\n        '4C':  {'opc': 'SSTAT', 'title': 'Service mode status', 'format': 'Session,Status', 'minpri': 3, 'comment': 'Status returned by command station/programmer at end of programming operation that does not return data.'},\n        '50':  {'opc': 'RQNN', 'title': 'Request node number', 'format': 'NN', 'minpri': 3, 'comment': 'Sent by a node that is in setup/configuration mode and requests assignment of a node number (NN). The node allocating node numbers responds with (SNN) which contains the newly assigned node number. &lt;NN hi&gt; and &lt;NN lo&gt; are the existing node number, if the node has one. If it does not yet have a node number, these bytes should be set to zero.'},\n        '51':  {'opc': 'NNREL', 'title': 'Node number release', 'format': 'NN', 'minpri': 3, 'comment': 'Sent by node when taken out of service. e.g. when reverting to SLiM mode.'},\n        '52':  {'opc': 'NNACK', 'title': 'Node number acknowledge', 'format': 'NN', 'minpri': 3, 'comment': 'Sent by a node to verify its presence and confirm its node id. This message is sent to acknowledge an SNN.'},\n        '53':  {'opc': 'NNLRN', 'title': 'Set node into learn mode', 'format': 'NN', 'minpri': 3, 'comment': 'Sent by a configuration tool to put a specific node into learn mode. Deprecated - replaced by MODE'},\n        '54':  {'opc': 'NNULN', 'title': 'Release node from learn mode', 'format': 'NN', 'minpri': 3, 'comment': 'Sent by a configuration tool to take node out of learn mode and revert to normal operation.'},\n        '55':  {'opc': 'NNCLR', 'title': 'Clear all events from a node', 'format': 'NN', 'minpri': 3, 'comment': 'Sent by a configuration tool to clear all events from a specific node. Must be in learn mode first to safeguard against accidental erasure of all events.'},\n        '56':  {'opc': 'NNEVN', 'title': 'Read number of events available in a node', 'format': 'NN', 'minpri': 3, 'comment': 'Sent by a configuration tool to read the number of available event slots in a node.Response is EVLNF (0x70)'},\n        '57':  {'opc': 'NERD', 'title': 'Read back all stored events in a node', 'format': 'NN', 'minpri': 3, 'comment': 'Sent by a configuration tool to read all the stored events in a node. Response is 0xF2.'},\n        '58':  {'opc': 'RQEVN', 'title': 'Request to read number of stored events', 'format': 'NN', 'minpri': 3, 'comment': 'Sent by a configuration tool to read the number of stored events in a node. Response is 0x74( NUMEV).'},\n        '59':  {'opc': 'WRACK', 'title': 'Write acknowledge', 'format': 'NN', 'minpri': 3, 'comment': 'Sent by a node to indicate the completion of a write to memory operation. All nodes must issue WRACK when a write operation to node variables, events or event variables has completed. This allows for teaching nodes where the processing time may be slow. Deprecated replaced by GRSP'},\n        '5A':  {'opc': 'RQDAT', 'title': 'Request node data event', 'format': 'NN', 'minpri': 3, 'comment': 'Sent by one node to read the data event from another node.(eg: RFID data). Response is 0xF7 (ARDAT).'},\n        # DN = Device number\n        '5B':  {'opc': 'RQDDS', 'title': 'Request device data - short mode', 'format': 'DNHigh_DNLow', 'minpri': 3, 'comment': 'To request a data set from a device using the short event method. where DN is the device number. Response is 0xFB (DDRS)'},\n        '5C':  {'opc': 'BOOTM', 'title': 'Put node into bootload mode', 'format': 'NN', 'minpri': 3, 'comment': 'For SliM nodes with no NN then the NN of the command must be zero. For SLiM nodes with an NN, and all FLiM nodes the command must contain the NN of the target node. Sent by a configuration tool to prepare for loading a new program. Deprecated replaced by MODE'},\n        '5D':  {'opc': 'ENUM', 'title': 'Force a self enumeration cyble for use with CAN', 'format': 'NN', 'minpri': 3, 'comment': 'For nodes in FLiM using CAN as transport. This OPC will force a self-enumeration cycle for the specified node. A new CAN_ID will be allocated if needed. Following the ENUM sequence, the node should issue a NNACK to confirm completion and verify the new CAN_ID. If no CAN_ID values are available, an error message 7 will be issued instead. Deprecated replaced with automatic self enumeration.'},\n        '5F':  {'opc': 'EXTC1', 'title': 'Extended op-code with 1 additional byte', 'format': 'ExtOpc,Byte1', 'minpri': 3, 'comment': 'Used if the basic set of 32 OPCs is not enough. Allows an additional 256 OPCs'},\n        # 3rd data section\n        '60':  {'opc': 'DFUN', 'title': 'Set Engine functions', 'format': 'Session,Fn1,Fn2', 'minpri': 2, 'comment': '&lt;Dat2&gt; (Fn1) is the function range. 1 is F0(FL) to F4; 2 is F5 to F8; 3 is F9 to F12; 4 is F13 to F20; 5 is F21 to F28; &lt;Dat3&gt; (Fn2) is the NMRA DCC format function byte for that range in corresponding bits. Sent by a CAB or equivalent to request an engine Fn state change.'},\n        '61':  {'opc': 'GLOC', 'title': 'Get engine session', 'format': 'AddrHigh_AddrLow,Flags', 'minpri': 2, 'comment': '&lt;Dat1&gt; and &lt;Dat2&gt; are [AddrH] and [AddrL] of the decoder, respectively.; 7 bit addresses have (AddrH=0).; 14 bit addresses have bits 6,7 of AddrH set to 1.; &lt;Flags&gt; contains flag bits as follows:Bit 0: Set for \"Steal\" mode; Bit 1: Set for \"Share\" mode; Both bits set to 0 is exactly equivalent to an RLOC request; Both bits set to 1 is invalid, because the 2 modes are mutually exclusive; The command station responds with (PLOC) if the request is successful. Otherwise responds with (ERR): engine in use. (ERR:) stack full or (ERR) no session. The latter indicates that there is no current session to steal/share depending on the flag bits set in the request. GLOC with all flag bits set to zero is exactly equivalent to RLOC, but command stations must continue to support RLOC for backwards compatibility.'},\n        '63':  {'opc': 'ERR', 'title': 'Command station error report', 'format': 'Byte1,Byte2,ErrCode', 'minpri': 2, 'comment': 'Sent in response to an error situation by a command station.'},\n        '6F':  {'opc': 'CMDERR', 'title': 'Error messages from nodes during configuration', 'format': 'NN,Error', 'minpri': 3, 'comment': 'Sent by node if there is an error when a configuration command is sent. Deprecated replaced by GRSP.'},\n        '70':  {'opc': 'EVNLF', 'title': 'Event space left reply from node', 'format': 'NN,EVSPC', 'minpri': 3, 'comment': 'EVSPC is a one byte value giving the number of available events left in that node.'},\n        '71':  {'opc': 'NVRD', 'title': 'Request read of a node variable', 'format': 'NN,NVIndex', 'minpri': 3, 'comment': 'NV# is the index for the node variable value requested. Response is NVANS. VLCB also returns GRSP and support for NV#0.'},\n        '72':  {'opc': 'NENRD', 'title': 'Request read of stored events by event index', 'format': 'NN,EnIndex', 'minpri': 3, 'comment': 'EN# is the index for the stored event requested. Response is 0xF2 (ENRSP)'},\n        '73':  {'opc': 'RQNPN', 'title': 'Request read of a node parameter by index', 'format': 'NN,ParaIndex', 'minpri': 3, 'comment': 'Para# is the index for the parameter requested. Index 0 returns the number of available parameters, Response is 0x9B (PARAN). VLCB Para #0 returns a PARAN for each parameter'},\n        '74':  {'opc': 'NUMEV', 'title': 'Number of events stored in node', 'format': 'NN,NumEvents', 'minpri': 3, 'comment': 'Response to request 0x58 (RQEVN)'},\n        '75':  {'opc': 'CANID', 'title': 'Set a CAN_ID in existing FLiM node', 'format': 'NN,CAN_ID', 'minpri': 0, 'comment': 'Used to force a specified CAN_ID into a node. Value range is from 1 to 0x63 (99 decimal) This OPC must be used with care as duplicate CAN_IDs are not allowed. Values outside the permitted range will produce an error 7 message and the CAN_ID will not change. Deprecated replaced with self-enumaration. VLCB includes GRSP responses.'},\n        '76':  {'opc': 'MODE', 'title': 'Request a change to a modules operating mode', 'format': 'NN,ModeCmd', 'minpri': 0, 'comment': 'Request to change the operational mode of the module. Mode cmds 0 = transition to setup mode, 1 = transition to normal mode, 16 = turn on FCU compat, 17 = turn off FCU compat. If supported then module returns GRSP. VLCB new features.'},\n        '78':  {'opc': 'RQSD', 'title': 'Request service discover', 'format': 'NN,ServiceIndex', 'minpri': 0, 'comment': 'Request service data from a module if ServiceIndex is 0 then SD message sent, followed by ESD response for each services supported. VLCB new feature.'},\n        '7F':  {'opc': 'EXTC2', 'title': 'Extended op-code with 2 additional bytes', 'format': 'ExtOpc,Byte1,Byte2', 'minpri': 0, 'comment': 'Used if the basic set of 32 OPCs is not enough. Allows an additional 256 OPCs'},\n        # 4 data byte packets\n        '80':  {'opc': 'RDCC3', 'title': 'Request 3-byte DCC Packet', 'format': 'Rep,Byte1,Byte2,Byte3', 'minpri': 3, 'comment': '&lt;Dat1(REP)&gt; is number of repetitions in sending the packet. &lt;Dat2&gt;..&lt;Dat4&gt; 3 bytes of the DCC packet. Allows a CAB or equivalent to request a 3 byte DCC packet to be sent to the track. The packet is sent &lt;REP&gt; times and is not refreshed on a regular basis. Note: a 3 byte DCC packet is the minimum allowed.'},\n        '82':  {'opc': 'WCVO', 'title': 'Write CV (byte) in OPS mode', 'format': 'Session,CVHigh_CVLow,CVVal', 'minpri': 2, 'comment': '&lt;Dat1&gt; is the session number of the loco to be written to; &lt;Dat2&gt; is the MSB # of the CV to be written (supports CVs 1 - 65536); &lt;Dat3&gt; is the LSB # of the CV to be written; &lt;Dat4&gt; is the byte value to be written; Sent to the command station to write a DCC CV byte in OPS mode to specific loco.(on the main)'},\n        '83':  {'opc': 'WCVB', 'title': 'Write CV (bit) in OPS mode', 'format': 'Session,CVHigh_CVLow,CVVal', 'minpri': 2, 'comment': '&lt;Dat1&gt; is the session number of the loco to be written to; &lt;Dat2&gt; is the MSB # of the CV to be written (supports CVs 1 - 65536); &lt;Dat3&gt; is the LSB # of the CV to be written; &lt;Dat4&gt; is the value to be written; The format for Dat4 is that specified in RP 9.2.1 for OTM bit manipulation in a DCC packet.; This is ?111CDBBB? where C is here is always 1 as only ?writes? are possible OTM. (unless some loco ACK scheme like RailCom is used). D is the bit value, either 0 or 1 and BBB is the bit position in the CV byte. 000 to 111 for bits 0 to 7.; Sent to the command station to write a DCC CV in OPS mode to specific loco.(on the main)'},\n        '84':  {'opc': 'QCVS', 'title': 'Read CV', 'format': 'Session,CVHigh_CVLow,Mode', 'minpri': 2, 'comment': 'This command is used exclusively with service mode.; Sent by the cab to the command station in order to read a CV value. The command station shall respond with a PCVS message containing the value read, or SSTAT if the CV cannot be read.'},\n        '85':  {'opc': 'PCVS', 'title': 'Report CV', 'format': 'Session,CVHigh_CVLow,CVVal', 'minpri': 2, 'comment': '&lt;Dat1&gt; is the session number of the cab; &lt;Dat2&gt; is the MSB # of the CV read (supports CVs 1 - 65536); &lt;Dat3&gt; is the LSB # of the CV read; &lt;Dat4&gt; is the read value; This command is used exclusively with service mode.; Sent by the command station to report a read CV.'},\n        '87':  {'opc': 'RDGN', 'title': 'Request dianostic data', 'format': 'NN,ServiceIndex,DiagCode', 'minpri': 0, 'comment': 'Request diagnostic data from a module. If DiagCode is 0 then all data returned. If ServiceIndex 0 then send DGN message for each service, otherwise send DGN for service specified'},\n        '8E':  {'opc': 'NVSETRD', 'title': 'Set an NV value with read back', 'format': 'NN,NNIndex,NVVal', 'minpri': 0, 'comment': 'Sets an NV value and responds with the new value, response may not be the value requested. VLCB new feature.'},\n        '90':  {'opc': 'ACON', 'title': 'Accessory ON', 'format': 'NN,EnHigh_EnLow', 'minpri': 3, 'comment': '&lt;Dat1&gt; is the high byte of the node number; &lt;Dat2&gt; is the low byte of the node number; &lt;Dat3&gt; is the high byte of the event number; &lt;Dat4&gt; is the low byte of the event number; Indicates an ?ON? event using the full event number of 4 bytes. (long event)'},\n        '91':  {'opc': 'ACOF', 'title': 'Accessory OFF', 'format': 'NN,EnHigh_EnLow', 'minpri': 3, 'comment': '&lt;Dat1&gt; is the high byte of the node number; &lt;Dat2&gt; is the low byte of the node number; &lt;Dat3&gt; is the high byte of the event number; &lt;Dat4&gt; is the low byte of the event number; Indicates an ?OFF? event using the full event number of 4 bytes. (long event)'},\n        '92':  {'opc': 'AREQ', 'title': 'Accessory Request Event', 'format': 'NN,EnHigh_EnLow', 'minpri': 3, 'comment': '&lt;Dat1&gt; is the high byte of the node number (MS WORD of the full event #); &lt;Dat2&gt; is the low byte of the node number (MS WORD of the full event #); &lt;Dat3&gt; is the high byte of the event number; &lt;Dat4&gt; is the low byte of the event number; Indicates a ?request? event using the full event number of 4 bytes. (long event); A request event is used to elicit a status response from a producer when it is required to know the state of the producer without producing an ON or OFF event and to trigger an event from a combi node'},\n        '93':  {'opc': 'ARON', 'title': 'Accessory Response Event', 'format': 'NN,EnHigh_EnLow', 'minpri': 3, 'comment': 'Indicates an ?ON? response event. A response event is a reply to a status request (AREQ) without producing an ON or OFF event.'},\n        '94':  {'opc': 'AROF', 'title': 'Accessory Response Event', 'format': 'NN,EnHigh_EnLow', 'minpri': 3, 'comment': '&lt;Dat1&gt; is the high byte of the node number; &lt;Dat2&gt; is the low byte of the node number; &lt;Dat3&gt; is the high byte of the event number; &lt;Dat4&gt; is the low byte of the event number; Indicates an \u2018OFF\u2019 response event. A response event is a reply to a status request; (AREQ) without producing an ON or OFF event'},\n        '95':  {'opc': 'EVULN', 'title': 'Unlearn an event in learn mode', 'format': 'NN,EnHigh_EnLow', 'minpri': 3, 'comment': 'Sent by a configuration tool to remove an event from a node. VLCB also return GRSP.'},\n        # NVIndex is NV Index number\n        '96':  {'opc': 'NVSET', 'title': 'Set a node variable', 'format': 'NN,NVIndex,NVVal', 'minpri': 3, 'comment': 'Sent by a configuration tool to set a node variable. NV# is the NV index number. Deprecated replaced by NVSETRD. VLCB also return GRSP.'},\n        '97':  {'opc': 'NVANS', 'title': 'Response to a request for a node variable value', 'format': 'NN,NVIndex,NVVal', 'minpri': 3, 'comment': 'Sent by node in response to request. (NVRD)'},\n        # Short events\n        # DNHigh, DNLow = Lower two bytes define device number - considered same as a device address - full 4byte event is still sent\n        # &lt;Dat1&gt; is the high byte of the node number; &lt;Dat2&gt; is the low byte of the node number; &lt;Dat3&gt; is the high byte of the Device Number; &lt;Dat4&gt; is the low byte of the Device Number\n        '98':  {'opc': 'ASON', 'title': 'Accessory short ON', 'format': 'NN,DNHigh_DNLow', 'minpri': 3, 'comment': 'Indicates an \u2018ON\u2019 event using the short event number of 2 LS bytes.'},\n        '99':  {'opc': 'ASOF', 'title': 'Accessory short OFF', 'format': 'NN,DNHigh_DNLow', 'minpri': 3, 'comment': 'Indicates an \u2018OFF\u2019 event using the short event number of 2 LS bytes.'},\n        '9A':  {'opc': 'ASRQ', 'title': 'Accessory Short Request Event', 'format': 'NN,DNHigh_DNLow', 'minpri': 3, 'comment': 'Indicates a \u2018request\u2019 event using the short event number of 2 LS bytes. A request event is used to elicit a response from a producer \u2018device\u2019 when it is required to know the \u2018state\u2019 of the device without producing an ON or OFF event and to trigger an event from a combi node.'},\n        # ParaIndex = Index of parameter\n        # ParaVal = Parameter value\n        '9B':  {'opc': 'PARAN', 'title': 'Response to request for individual node parameter', 'format': 'NN,ParaIndex,ParaVal', 'minpri': 3, 'comment': 'NN is the node number of the sending node. Para# is the index of the parameter and Para val is the parameter value.'},\n        # EnIndex is event index\n        # EvIndex is Event variable index\n        '9C':  {'opc': 'REVAL', 'title': 'Request for read of an event variable', 'format': 'NN,EnIndex,EvIndex', 'minpri': 3, 'comment': 'This request differs from B2 (REQEV) as it doesn\u2019t need to be in learn mode but does; require the knowledge of the event index to which the EV request is directed.; EN# is the event index. EV# is the event variable index. Response is B5 (NEVAL)'},\n        '9D':  {'opc': 'ARSON', 'title': 'Accessory short response event', 'format': 'NN,DNHigh_DNLow', 'minpri': 3, 'comment': 'Indicates an \u2018ON\u2019 response event. A response event is a reply to a status request (ASRQ) without producing an ON or OFF event.'},\n        '9E':  {'opc': 'ARSOF', 'title': 'Accessory short response event', 'format': 'NN,DNHigh_DNLow', 'minpri': 3, 'comment': 'ndicates an \u2018OFF\u2019 response event. A response event is a reply to a status request (ASRQ) without producing an ON or OFF event.'},\n        '9F':  {'opc': 'EXTC3', 'title': 'Extended op-code with 3 additional bytes', 'format': 'ExtOpc,Byte1,Byte2,Byte3', 'minpri': 0, 'comment': 'Used if the basic set of 32 OPCs is not enough. Allows an additional 256 OPCs'},\n        # 5 data byte packets\n        # Rep = repeat\n        'A0':  {'opc': 'RDCC4', 'title': 'Request 4-byte DCC packet', 'format': 'Rep,Byte1,Byte2,Byte3,Byte4', 'minpri': 2, 'comment': '&lt;Dat1(REP)&gt; is number of repetitions in sending the packet.; &lt;Dat2&gt;..&lt;Dat5&gt; 4 bytes of the DCC packet.; Allows a CAB or equivalent to request a 4 byte DCC packet to be sent to the track. The; packet is sent &lt;REP&gt; times and is not refreshed on a regular basis.'},\n        # CVHigh MSB of CV (1-65536)\n        # CVLow LSB of CV\n        # Mode - service write mode\n        #CVVal - CV value\n        'A2':  {'opc': 'WCVS', 'title': 'Write CV in Service Mode', 'format': 'Session,CVHigh_CVLow,Mode,CVVal', 'minpri': 0, 'comment': '&lt;Dat1&gt; is the session number of the cab; &lt;Dat2&gt; is the MSB # of the CV to be written (supports CVs 1 - 65536); &lt;Dat3&gt; is the LSB # of the CV to be written; &lt;Dat4&gt; is the service write mode; &lt;Dat5&gt; is the CV value to be written; Sent to the command station to write a DCC CV in service mode.'},\n        'AB':  {'opc': 'HEARTB', 'title': 'Heartbeat message from module', 'format': 'NN,Sequence,Status,StatusBits', 'minpri': 0, 'comment': 'Hearbeat message from module indicating alive. Sent every 5 seconds by module. Sequence count from 0, incrementing and wrap around to 0., Statis is binary representation of diagnostic status 0x00 is normal operation. StatusBits is reserved set to 0x00. VLCB new feature.'},\n        'AC':  {'opc': 'SD', 'title': 'Service discovery response', 'format': 'NN,ServiceIndex,ServiceType,Version', 'minpri': 0, 'comment': 'Version of service supported response to RQSD with ServiceIndex = 0. First SD response is number of following SD responses. Also see ESD. VLCB new feature.'},\n        'AF':  {'opc': 'GRSP', 'title': 'Generic response', 'format': 'NN,Opcode,ServiceType,Result', 'minpri': 0, 'comment': 'Generic response for a config change request. Result byte indicates ok for success or error code. CMDERR codes are supported. VLCB new feature.'},\n        'B0':  {'opc': 'ACON1', 'title': 'Accessory ON', 'format': 'NN,EnHigh_EnLow,Byte1', 'minpri': 3, 'comment': '&lt;Dat1&gt; is the high byte of the node number; &lt;Dat2&gt; is the low byte of the node number; &lt;Dat3&gt; is the high byte of the event number; &lt;Dat4&gt; is the low byte of the event number; &lt;Dat5&gt; is an additional data byte; Indicates an \u2018ON\u2019 event using the full event number of; 4 bytes with one additional data byte.'},\n        'B1':  {'opc': 'ACOF1', 'title': 'Accessory OFF', 'format': 'NN,EnHigh_EnLow,Byte1', 'minpri': 3, 'comment': '&lt;Dat1&gt; is the high byte of the node number; &lt;Dat2&gt; is the low byte of the node number; &lt;Dat3&gt; is the high byte of the event number; &lt;Dat4&gt; is the low byte of the event number; &lt;Dat5&gt; is an additional data byte; Indicates an \u2018OFF\u2019 event using the full event number of 4 bytes with one additional data byte.'},\n        'B2':  {'opc': 'REQEV', 'title': 'Read event variable in learn mode', 'format': 'NN,EnHigh_EnLow,EvIndex', 'minpri': 3, 'comment': 'Allows a configuration tool to read stored event variables from a node. EV# is the EV index. Reply is (EVANS)'},\n        'B3':  {'opc': 'ARON1', 'title': 'Accessory Response Event', 'format': 'NN,EnHigh_EnLow,Byte1', 'minpri': 3, 'comment': 'Indicates an \u2018ON\u2019 response event with one additional data byte. A response event is a reply to a status request (AREQ) without producing an ON or OFF event.'},\n        'B4':  {'opc': 'AROF1', 'title': 'Accessory Response Event', 'format': 'NN,EnHigh_EnLow,Byte1', 'minpri': 3, 'comment': 'Indicates an \u2018OFF\u2019 response event with one additional data byte. A response event is a reply to a status request (AREQ) without producing an ON or OFF event.'},\n        # NNHigh, NNLow node replying\n        # EvVal is value of Event Variable\n        'B5':  {'opc': 'NEVAL', 'title': 'Response to request for read of EV value', 'format': 'NN,EnIndex,EvIndex,EvVal', 'minpri': 3, 'comment': 'NN is the node replying. EN# is the index of the event in that node. EV# is the index of the event variable. EVval is the value of that EV. This is response to 9C (REVAL)'},\n        'B6':  {'opc': 'PNN', 'title': 'Response to Query Node', 'format': 'NN,ManufId,ModId,Flags', 'minpri': 3, 'comment': '&lt;NN Hi&gt; is the high byte of the node number; &lt;NN Lo&gt; is the low byte of the node number; &lt;Manuf Id&gt; is the Manufacturer id as defined in the node parameters; &lt;Module Id&gt; is the Module Type Id id as defined in the node parameters; &lt;Flags&gt; is the node flags as defined in the node parameters. The Flags byte contains bit flags as follows:; Bit 0: Set to 1 for consumer node; Bit 1: Set to 1 for producer node; Bit 2: Set to 1 for FLiM mode; Bit 3: Set to 1 for Bootloader compatible; If a module is both a producer and a consumer then it is referred to as a combi node and; both flags will be set.; Every node should send this message in response to a QNN message.'},\n        'B8':  {'opc': 'ASON1', 'title': 'Accessory Short ON', 'format': 'NN,DNHigh_DNLow,Byte1', 'minpri': 3, 'comment': 'Indicates an \u2018ON\u2019 event using the short event number of 2 LS bytes with one added data byte.'},\n        'B9':  {'opc': 'ASOF1', 'title': 'Accessory Short OFF', 'format': 'NN,DNHigh_DNLow,Byte1', 'minpri': 3, 'comment': 'Indicates an \u2018OFF\u2019 event using the short event number of 2 LS bytes with one added data byte.'},\n        'BD':  {'opc': 'ARSON1', 'title': 'Accessory Short Response Event with one data byte', 'format': 'NN,DNHigh_DNLow,Byte1', 'minpri': 3, 'comment': 'Indicates an \u2018ON\u2019 response event with one added data byte. A response event is a reply to a status request (ASRQ) without producing an ON or OFF event.'},\n        'BE':  {'opc': 'ARSOF1', 'title': 'Accessory short response event with one data byte', 'format': 'NN,DNHigh_DNLow,Byte1', 'minpri': 3, 'comment': 'Indicates an \u2018OFF\u2019 response event with one added data byte. A response event is a reply to a status request (ASRQ) without producing an ON or OFF event.'},\n        'BF':  {'opc': 'EXTC4', 'title': 'Extended op-code with 4 data bytes', 'format': 'ExtOpc,Byte1,Byte2,Byte3,Byte4', 'minpri': 3, 'comment': 'Used if the basic set of 32 OPCs is not enough. Allows an additional 256 OPCs.'},\n        # 6 data byte packets\n        'C0':  {'opc': 'RDCC5', 'title': 'Requst 5-byte DCC packet', 'format': 'Rep,Byte1,Byte2,Byte3,Byte4,Byte5', 'minpri': 2, 'comment': '&lt;Dat1(REP)&gt; is # of repetitions in sending the packet.; &lt;Dat2&gt;..&lt;Dat6&gt; 5 bytes of the DCC packet.; Allows a CAB or equivalent to request a 5 byte DCC packet to be sent to the track. The packet is sent &lt;REP&gt; times and is not refreshed on a regular basis.'},\n        'C1':  {'opc': 'WCVOA', 'title': 'Write CV (byte) in OPS mode by address', 'format': 'AddrHigh_AddrLow,CVHigh_CVLow,Mode,CVVal', 'minpri': 2, 'comment': '&lt;Dat1&gt; and &lt;Dat2&gt; are [AddrH] and [AddrL] of the decoder, respectively.; 7 bit addresses have (AddrH=0).; 14 bit addresses have bits 7,8 of AddrH set to 1.; &lt;Dat3&gt; is the MSB # of the CV to be written (supports CVs 1 - 65536); &lt;Dat4&gt; is the LSB # of the CV to be written; &lt;Dat5&gt; is the programming mode to be used; &lt;Dat6&gt; is the CV byte value to be written; Sent to the command station to write a DCC CV byte in OPS mode to specific loco (on the main). Used by computer based ops mode programmer that does not have a valid throttle handle.'},\n        'C2':  {'opc': 'CABDAT', 'title': 'Send data to DCC CAB which is controlling loco', 'format': 'AddrHigh_AddrLow,DataCode,Byte1,Byte2,Byte3', 'minpri': 1, 'comment': 'Send data to DCC CAB controlling particular loco. CABSIG data1 for aspect1, data2 for aspect2, data3 for speed. Defined in RFC0005.'},\n        'C7':  {'opc': 'DGN', 'title': 'Dianostic data resonse', 'format': 'NN,ServiceIndex,DiagCode,DiagVal', 'minpri': 0, 'comment': 'Diagnostic data value from a module sent in response to RDGN. VLCB new features'},\n        'CF':  {'opc': 'FCLK', 'title': 'Fast Clock', 'format': 'DateTime', 'minpri': 3, 'comment': 'This addendum defines a time encoding'},\n        'D0':  {'opc': 'ACON2', 'title': 'Accessory ON', 'format': 'NN,EnHigh_EnLow,Byte1,Byte2', 'minpri': 3, 'comment': 'Indicates an \u2018ON\u2019 event using the full event number of 4 bytes with two additional data bytes.'},\n        'D1':  {'opc': 'ACOF2', 'title': 'Accessory OFF', 'format': 'NN,EnHigh_EnLow,Byte1,Byte2', 'minpri': 3, 'comment': 'ndicates an \u2018OFF\u2019 event using the full event number of 4 bytes with two additional data bytes.'},\n        'D2':  {'opc': 'EVLRN', 'title': 'Teach an event in learn mode', 'format': 'NN,EnHigh_EnLow,EvIndex,EvVal', 'minpri': 3, 'comment': 'A node response to a request from a configuration tool for the EVs associated with an event (REQEV). For multiple EVs, there will be one response per request. VLCB also return GRSP.'},\n        'D3':  {'opc': 'EVANS', 'title': 'Response to a request for an EV value in a node in learn mode', 'format': 'NN,EnHigh_EnLow,EvIndex,EvVal', 'minpri': 3, 'comment': 'A node response to a request from a configuration tool for the EVs associated with an event (REQEV). For multiple EVs, there will be one response per request.'},\n        'D4':  {'opc': 'ARON2', 'title': 'Accessory Response Event', 'format': 'NN,EnHigh_EnLow,Byte1,Byte2', 'minpri': 3, 'comment': 'Indicates an \u2018ON\u2019 response event with two added data bytes. A response event is a reply to a status request (AREQ) without producing an ON or OFF event.'},\n        'D5':  {'opc': 'AROF2', 'title': 'Accessory Response Event', 'format': 'NN,EnHigh_EnLow,Byte1,Byte2', 'minpri': 3, 'comment': 'Indicates an \u2018OFF\u2019 response event with two added data bytes. A response event is a reply to a status request (AREQ) without producing an ON or OFF event.'},\n        'D8':  {'opc': 'ASON2', 'title': 'Accessory Short ON', 'format': 'NN,DNHigh_DNLow,Byte1,Byte2', 'minpri': 3, 'comment': 'Indicates an \u2018ON\u2019 event using the short event number of 2 LS bytes with two added data bytes.'},\n        'DD':  {'opc': 'ARSON2', 'title': 'Accessory Short Response Event with two bytes', 'format': 'NN,DNHigh_DNLow,Byte1,Byte2', 'minpri': 3, 'comment': 'Indicates an \u2018ON\u2019 response event with two added data bytes. A response event is a reply to a status request (ASRQ) without producing an ON or OFF event.'},\n        'DE':  {'opc': 'ARSOF2', 'title': 'Accessory Short Response Event with two bytes','format': 'NN,DNHigh_DNLow,Byte1,Byte2', 'minpri': 3, 'comment': 'Indicates an \u2018OFF\u2019 response event with two added data bytes. A response event is a reply to a status request (ASRQ) without producing an ON or OFF event.'},\n        'DF':  {'opc': 'EXTC5', 'title': 'Extended op-code with 5 data bytes', 'format': 'ExtOpc,Byte1,Byte2,Byte3,Byte4,Byte5', 'minpri': 3, 'comment': 'Used if the basic set of 32 OPCs is not enough. Allows an additional 256 OPCs'},\n         # 7 data byte packets\n        'E0':  {'opc': 'RDCC6', 'title': 'Request 6 byte DCC packet', 'format': 'Rep,Byte1,Byte2,Byte3,Byte4,Byte5', 'minpri': 2, 'comment': 'Allows a CAB or equivalent to request a 6 byte DCC packet to be sent to the track. The packet is sent &lt;REP&gt; times and is not refreshed on a regular basis.'},\n        'E1':  {'opc': 'PLOC', 'title': 'Engine Report', 'format': 'Session,AddrHigh_AddrLow,SpeedDir,Fn1,Fn2,Fn3', 'minpri': 2, 'comment': '&lt;Dat4&gt; is the Speed/Direction value. Bit 7 is the direction bit and bits 0-6 are the speed value.; &lt;Dat5&gt; is the function byte F0 to F4; &lt;Dat6&gt; is the function byte F5 to F8; &lt;Dat7&gt; is the function byte F9 to F12; A report of an engine entry sent by the command station. Sent in response to QLOC or as an acknowledgement of acquiring an engine requested by a cab (RLOC or GLOC).'},\n        'E2':  {'opc': 'NAME', 'title': 'Response to request for node name string', 'format': 'Char1_7', 'minpri': 3, 'comment': 'A node response while in \u2018setup\u2019 mode for its name string. Reply to (RQMN). The string for the module type is returned in char1 to char7, space filled to 7 bytes. The Module Name prefix , currently either CAN or ETH, depends on the Interface Protocol parameter, it is not included in the response, see section 12.2 for the definition of the parameters.'},\n        'E3':  {'opc': 'STAT', 'title': 'Command station status report', 'format': 'NN,CSNum,Flags,MajRev,MinRev,Build', 'minpri': 2, 'comment': '&lt;NN hi&gt; &lt;NN lo&gt; Gives node id of command station, so further info can be got from parameters or interrogating NVs; &lt;CS num&gt; For future expansion - set to zero at present; &lt;flags&gt; Flags as defined below; &lt;Major rev&gt; Major revision number; &lt;Minor rev&gt; Minor revision letter; &lt;Build no.&gt; Build number, always 0 for a released version.; &lt;flags&gt; is status defined by the bits below.; bits:; 0 - Hardware Error (self test); 1 - Track Error; 2 - Track On/ Off; 3 - Bus On/ Halted; 4 - EM. Stop all performed; 5 - Reset done; 6 - Service mode (programming) On/ Off; 7 \u2013 reserved; Sent by the command station in response to RSTAT.'},\n        'E7':  {'opc': 'ESD', 'title': 'Extended service discovery response', 'format': 'NN,ServiceIndex,ServiceType,Byte1,Byte2,Byte3', 'minpri':0, 'comment': 'Detailed information about a service supported by a module. Sent in response to RQSD where ServiceIndex is not 0. VLCB new feature'},\n        'E9':  {'opc': 'DTXC', 'title': 'Streaming protocol', 'format': 'StreamID,Sequence,Byte1,Byte2,Byte3,Byte4,Byte5', 'minpri': 0, 'comment': 'Used to transport relatively large block of data. StreamID is unique layout wide (&gt; 20). If Sequence num is 0x00 then bytes are MessageLen (2 bytes), CRC16 (2 bytes), Flags (1 byte reserved). Defined in RFC0005'},\n        'EF':  {'opc': 'PARAMS', 'title': 'Response to request for node parameters', 'format': 'Para1_7', 'minpri': 3, 'comment': 'A node response while in \u2018setup\u2019 mode for its parameter string. Reply to (RQNP)'},\n        'F0':  {'opc': 'ACON3', 'title': 'Accessory ON', 'format': 'NN,EnHigh_EnLow,Byte1,Byte2,Byte3', 'minpri': 3, 'comment': 'Indicates an ON event using the full event number of 4 bytes with three additional data bytes.'},\n        'F1':  {'opc': 'ACOF3', 'title': 'Accessory OFF', 'format': 'NN,EnHigh_EnLow,Byte1,Byte2,Byte3', 'minpri': 3, 'comment': 'Indicates an OFF event using the full event number of 4 bytes with three additional data bytes.'},\n        'F2':  {'opc': 'ENRSP', 'title': 'Response to request to read node events', 'format': 'NN,En3_0,EnIndex', 'minpri': 3, 'comment': 'Where the NN is that of the sending node. EN3 to EN0 are the four bytes of the stored event. EN# is the index of the event within the sending node. This is a response to either 57 (NERD) or 72 (NENRD)'},\n        'F3':  {'opc': 'ARON3', 'title': 'Acessory Response Event', 'format': 'NN,EnHigh_EnLow,Byte1,Byte2,Byte3', 'minpri': 3, 'comment': 'Indicates an \u2018ON\u2019 response event with three added data bytes. A response event is a reply to a status request (AREQ) without producing an ON or OFF event.'},\n        'F4':  {'opc': 'AROF3', 'title': 'Acessory Response Event', 'format': 'NN,EnHigh_EnLow,Byte1,Byte2,Byte3', 'minpri': 3, 'comment': 'Indicates an \u2018ON\u2019 response event with three added data bytes. A response event is a reply to a status request (AREQ) without producing an ON or OFF event.'},\n        'F5':  {'opc': 'EVLRNI', 'title': 'Teach and event in learn mode using event indexing', 'format': 'NN,EnHigh_EnLow,EnIndex,EvIndex,EvVal', 'minpri': 3, 'comment': 'Sent by a configuration tool to a node in learn mode to teach it an event. The event index must be known. Also teaches it the associated event variables.(EVs). This command is repeated for each EV required. VLCB allow zero events and zero EVid, also return GRSP.'},\n        'F6':  {'opc': 'ACDAT', 'title': 'Accessory node data event', 'format': 'NN,Byte1,Byte2,Byte3,Byte4,Byte5', 'minpri': 3, 'comment': 'Indicates an event from this node with 5 bytes of data. For example, this can be used to send the 40 bits of an RFID tag. There is no event number in order to allow space for 5 bytes of data in the packet, so there can only be one data event per node.'},\n        'F7':  {'opc': 'ARDAT', 'title': 'Accessory node data response', 'format': 'NN,Byte1,Byte2,Byte3,Byte4,Byte5', 'minpri': 3, 'comment': 'Indicates a node data response. A response event is a reply to a status request (RQDAT) without producing a new data event.'},\n        'F8':  {'opc': 'ASON3', 'title': 'Accessory Short ON', 'format': 'NN,DNHigh_DNLow,Byte1,Byte2,Byte3', 'minpri': 3, 'comment': 'Indicates an ON event using the short event number of 2 LS bytes with three added data bytes.'},\n        'F9':  {'opc': 'ASOF3', 'title': 'Accessory Short OFF', 'format': 'NN,DNHigh_DNLow,Byte1,Byte2,Byte3', 'minpri': 3, 'comment': 'Indicates an OFF event using the short event number of 2 LS bytes with three added data bytes.'},\n        'FA':  {'opc': 'DDES', 'title': 'Device data event (short mode)', 'format': 'DNHigh_DNLow,Byte1,Byte2,Byte3,Byte4,Byte5', 'minpri': 3, 'comment': 'Function is the same as F6 but uses device addressing so can relate data to a device attached to a node. e.g. one of several RFID readers attached to a single node.'},\n        'FB':  {'opc': 'DDRS', 'title': 'Device data response (short mode)', 'format': 'DNHigh_DNLow,Byte1,Byte2,Byte3,Byte4,Byte5', 'minpri': 3, 'comment': 'The response to a request for data from a device. (0x5B)'},\n        'FC':  {'opc': 'DDWS', 'title': 'Write data', 'format': 'DNHigh_DNLow,byte1,byte2,byte3,byte4,byte5', 'minpri': 0, 'comment': 'Used to write data to a device such as an RFID tag. For RC522 byte1 should be 0.'},\n        'FD':  {'opc': 'ARSON3', 'title': 'Accessory Short Response Event', 'format': 'NN,DNHigh_DNLow,Byte1,Byte2,Byte3', 'minpri': 3, 'comment': \"Indicates an ON response event with with three added data bytes. A response event is a reply to a status request (ASRQ) without producing an ON or OFF event.\"},\n        'FE':  {'opc': 'ARSOF3', 'title': 'Accessory Short Response Event', 'format': 'NN,DNHigh_DNLow,Byte1,Byte2,Byte3', 'minpri': 3, 'comment': \"Indicates an OFF response event with with three added data bytes. A response event is a reply to a status request (ASRQ) without producing an ON or OFF event.\"},\n        'FF':  {'opc': 'EXTC6', 'title': 'Extended op-code with 6 data bytes', 'format': 'ExtOpc,Byte1,Byte2,Byte3,Byte4,Byte5,Byte6', 'minpri': 3, 'comment': 'Used if the basic set of 32 OPCs is not enough. Allows an additional 256 OPCs'}\n        }\n\n    # Number of chars (2 per byte) in each field and how to show to use (eg. hex / num / char)\n    # Num vs Hex is just suggested formatting - stored as a number the same\n    # In char then it's ascii - otherwise normally convert to a number and return that\n    field_formats = {\n            \"Unknown\": [2, \"hex\"],        # Generic if not known how to format\n            \"CAN_ID\": [2, \"num\"],         # Canbus id\n            \"Session\": [2, \"hex\"],        # Engine session number\n            \"AddrHigh_AddrLow\": [4, \"num\"], # Address of dcoder (7 or 14 bit) - 14bit have bits 6,7 of AddrHigh set to 1\n            \"Consist\": [2, \"num\"],        # Consist ID\n            \"Index\": [2, \"num\"],          # Index of loco in consist\n            \"Status\": [2, \"hex\"],     \n            \"NN\": [4, \"num\"],    # Node number\n            \"AllocCode\": [2, \"num\"],       # Specific allocation code\n            \"SpeedDir\": [2, \"hex\"],\n            \"SpeedFlag\": [2, \"hex\"],       # Speed flags DDD-DDDDD\n            \"Fnum\": [2, \"num\"],            # Function number\n            \"Fn1\": [2,\"num\"],              # Function number (multi byte)\n            \"Fn2\": [2,\"num\"],              # Function number (multi byte)\n            \"Fn3\": [2,\"num\"],              # Function number (multi byte)\n            \"DNHigh_DNLow\": [4, \"num\"],    # Device number (aka Device address)\n            \"ExtOpc\": [2, \"char\"],         # Extended op code\n            \"Byte1\": [2, \"hex\"],           # Byte (eg extended)\n            \"Byte2\": [2, \"hex\"],           # Byte (eg extended)\n            \"Byte3\": [2, \"hex\"],           # Byte (eg extended)\n            \"Byte4\": [2, \"hex\"],           # Byte (eg extended)\n            \"Byte5\": [2, \"hex\"],           # Byte (eg extended)\n            \"Byte6\": [2, \"hex\"],           # Byte (eg extended)\n            \"CVHigh_CVLow\": [2, \"num\"],    # CV number (DCC Configuration variables)\n            \"CVVal\": [2, \"num\"],           # CV value \n            \"NVIndex\": [2, \"num\"],         # NV Node variable index\n            \"NVVal\": [2, \"hex\"],           # NV value\n            \"NumEvents\": [2, \"num\"],       # Number of events\n            \"ParaIndex\": [2, \"num\"],       # Index of node parameter\n            \"ParaVal\": [2, \"num\"],         # Value of node parameter\n            \"Para1_7\": [14, \"hex\"],        # Multiple parameters\n            \"EnHigh_EnLow\": [4, \"num\"],    # En\n            \"EnIndex\": [2, \"num\"],         # Index of Event\n            \"EvIndex\": [2, \"num\"],         # Index of Event variable\n            \"EvVal\": [2, \"num\"],           # Event variable value\n            \"Rep\": [2, \"num\"],             # Repeat, num of times to send signal\n            \"Mode\": [2, \"hex\"],            # Service write mode\n            \"ManufId\": [2, \"hex\"],         # Manufacturer\n            \"ModId\": [2, \"hex\"],           # Module\n            \"Flags\": [2, \"hex\"],           # Module flags\n            \"CSNum\": [2, \"hex\"],           # Zero (future expansion)\n            \"MajRev\": [2, \"num\"],          # Major revision number\n            \"MinRev\": [2, \"ascii\"],        # Minor revision letter\n            \"Build\": [2, \"num\"],           # Built number always 0 for a released version\n            \"DateTime\": [8, \"hex\"],        # Date and time encoded\n            \"Char1_7\": [14, \"ascii\"],      # Name string 7 bytes long - padded\n            \"En3_0\": [8, \"hex\"],           # 4 bytes of stored event\n            \"EVSPC\": [2, \"num\"],           # Amount of space available for events\n            \"ErrCode\": [2, \"hex\"],         # Short 1 byte error code\n            \"Error\": [4, \"hex\"],           # Error code\n            \"ModeCmd\": [2, \"num\"],         # New VLCB mode command\n            \"ServiceIndex\": [2, \"hex\"],    # New VLCB Index of services\n            \"DiagCode\": [2, \"hex\"],        # New VLCB Diagnostic data code\n            \"DiagVal\": [4, \"hex\"],         # New VLCB Diagnostic data value\n            \"Sequence\": [2, \"num\"],        # New VLCB Sequence number (also RFC0005 SequenceNum)\n            \"StatusBits\": [2, \"hex\"],      # New VLCB StatusBits\n            \"ServiceType\": [2, \"hex\"],     # New VLCB Service Type\n            \"Version\": [2, \"num\"],         # New VLCB Version of service definition\n            \"Opcode\": [2, \"hex\"],          # New VLCB Requested Opcode (in response)\n            \"Result\": [2, \"hex\"],          # New VLCB Result from GRSP\n            \"DataCode\": [2, \"hex\"],        # Used in CABDAT meaning of next 3 bytes\n            \"StreamID\": [2, \"num\"]         # StreamID must be unique for the layout\n        }\n\n    # Accessory Codes - provided for convenient lookup\n    accessory_codes = {\n        'on': [\n            'ACON',\n            'ASON',\n            'ACON1',\n            'ACON2',\n            'ACON3',\n            'ASON1',\n            'ASON2',\n            'ASON3'\n            ],\n        'off': [\n            'ACOF',\n            'ASOF',\n            'ACOF1',\n            'ACOF2',\n            'ACOF3',\n            'ASOF1',\n            'ASOF2',\n            'ASOF3'\n            ]\n        }\n\n    # DCC error codes as byte string lookup\n    dcc_error_codes = {\n        '01': 'Loco stack full',\n        '02': 'Loco address taken',\n        '03': 'Session not present',\n        '04': 'Consist empty',\n        '05': 'Loco not found',\n        '06': 'CAN bus error',\n        '07': 'Invalid request',\n        '08': 'Session cancelled'\n        }\n\n    # CMDERR / GRSP error codes as byte string lookup\n    grsp_error_codes = {\n        '00': 'OK',\n        '01': 'Invalid command',\n        '02': 'Not in learn mode',\n        '03': 'Not in setup mode',\n        '04': 'Too many events',\n        '05': 'No event',\n        '06': 'Invalid event variable index',\n        '07': 'Invalid event',\n        '08': 'Reserved',\n        '09': 'Invalid parameter index',\n        '0A': 'Invalid node variable index',\n        '0B': 'Invalid event variable value',\n        '0C': 'Invalid node variable value',\n        '0D': 'Other in learn mode',\n        'FA': 'Invalid mode',\n        'FB': 'Invalid command parameter',\n        'FC': 'Invalid service',\n        'FD': 'Invalid diagnostic',\n        'FE': 'Unknown NVM type',\n        'FF': 'Reserved'\n        }\n\n\n\n    # Shorten op-code (remove extra characters)\n    # Used to allow methods to be used if mnemonic is included in op-code\n    # Or you could pass the entire data section\n    @staticmethod\n    def opcode_extract (opcode_string: str) -&gt; str:\n        \"\"\"Shortens op code by removing extra characters\n\n        Returns:\n            String: shortened opcode string\n\n        Raises:\n            ValueError: If string does not contain at least 2 characters\n        \"\"\"\n        if len(opcode_string) &gt;= 2:\n            return opcode_string[0:2]\n        else:\n            raise ValueError(f\"String {opcode_string} is too short.\")\n\n    # Get min priority from opcode\n    @staticmethod\n    def opcode_priority (opcode: str) -&gt; int:\n        \"\"\"Get priority from opcode\n\n        Returns:\n            int: priority value\n\n        Raises:\n            ValueError: If opcode not found\n        \"\"\"\n        opcode = VLCBOpcode.opcode_extract(opcode)\n        if opcode in VLCBOpcode.opcodes.keys():\n            return VLCBOpcode.opcodes[opcode]['minpri']\n        else:\n            raise ValueError(f\"Opcode {opcode} is not defined.\")\n\n    # Title of opcode (used in tooltip)\n    @staticmethod\n    def opcode_title (opcode: str) -&gt; str:\n        \"\"\"Get title from opcode\n\n        Returns:\n            String: Opcode Title\n\n        Raises:\n            ValueError: If opcode not found\n        \"\"\"\n        opcode = VLCBOpcode.opcode_extract(opcode)\n        if opcode in VLCBOpcode.opcodes.keys():\n            return VLCBOpcode.opcodes[opcode]['title']\n        else:\n            raise ValueError(f\"Opcode {opcode} is not defined.\")\n\n    # Convert op-code to mnemonic\n    @staticmethod\n    def opcode_mnemonic (opcode):\n        \"\"\"Get mnemonic from opcode\n\n        Returns:\n            String: Opcode mnemonic\n\n        Raises:\n            ValueError: If opcode not found\n        \"\"\"\n        opcode = VLCBOpcode.opcode_extract(opcode)\n        if opcode in VLCBOpcode.opcodes.keys():\n            return VLCBOpcode.opcodes[opcode]['opc']\n        else:\n            raise ValueError(f\"Opcode {opcode} is not defined.\")\n\n    # Parse the data based on the format str and store in a dictionary\n    @staticmethod\n    def parse_data (data: str) -&gt; OpcodeData:\n        \"\"\"Returns the data associated with the data string as a dict\n\n        Returns:\n            OpcodeData: Dict in OpcodeData format\n\n        Raises:\n            ValueError: If opcode not found\n        \"\"\"\n        # Does not raise any explicit exceptions but uses methods that could raise a ValueError\n        opcode = VLCBOpcode.opcode_extract(data)\n        # strip opcode from data\n        data = data[2:]\n\n        #print (f\"Data {data}\")\n        # Include opcode in data if required for future use\n        data_parsed = {'opid': opcode}\n        # check valid opcode (if not then empty format)\n        if not opcode in VLCBOpcode.opcodes.keys():\n            format = \"\"\n            data_parsed['opcode'] = \"UNKNOWN\"\n        else:\n            format = VLCBOpcode.opcodes[opcode]['format']\n            data_parsed['opcode'] = VLCBOpcode.opcodes[opcode]['opc']\n        format_fields = format.split(',')\n        # Remove data as added to dict so when reach 0 we are complete\n        # parse each of the fields\n        for this_field in format_fields:\n            # If no format then skip and add any data at end\n            if this_field == \"\":\n                break\n            # If unknown then flag here - should only get this during unittests if a new format is added\n            if this_field not in VLCBOpcode.field_formats.keys():\n                logging.warning (f\"Warning format field {this_field} not recognised\")\n                this_field = \"Unknown\"\n            # Take number of bytes from remaining data\n            # Check enough first - if not then add warning\n            num_chars = VLCBOpcode.field_formats[this_field][0] \n            if len(data) &lt; num_chars :\n                data_parsed[this_field] = f\"Insufficient data {data}\"\n                # remove remaining\n                data = \"\"\n            else:\n                # Move number of chars (typically 2 chars per byte) into this_val\n                this_val = data[0:num_chars]\n                data = data[num_chars:]\n                # if number expected then convert\n                if VLCBOpcode.field_formats[this_field][1] != \"char\":\n                    this_val = int(this_val, 16)\n                data_parsed[this_field] = this_val\n        # remaining data added to final field (shouldn't normally get this)\n        if len(data) &gt; 0:\n            data_parsed[\"ExtraData\"] = data\n        return data_parsed\n</code></pre> <p>Utils for use by other parts of the library</p>"},{"location":"reference/#pyvlcb.VLCB.__init__","title":"<code>__init__(can_id=60)</code>","text":"<p>Inits VLCB with a can_id</p> <p>Parameters:</p> Name Type Description Default <code>can_id</code> <code>Optional[int]</code> <p>The can_id for the software (default = 60)</p> <code>60</code> Source code in <code>src/pyvlcb/__init__.py</code> <pre><code>def __init__ (self, can_id: Optional[int] = 60) -&gt; None:\n    \"\"\"Inits VLCB with a can_id\n\n    Args:\n        can_id: The can_id for the software (default = 60)\n    \"\"\"\n    self.can_id = can_id\n    self.debug = False\n</code></pre>"},{"location":"reference/#pyvlcb.VLCB.accessory_command","title":"<code>accessory_command(node_id, ev_id, state)</code>","text":"<p>Create an accessory command</p> <p>Uses appropriate Accessory On / Off command Defaulting to short, but using long if &gt; 0xffff</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>Node ID to query</p> required <code>ev_id</code> <code>int</code> <p>Event ID</p> required <code>state</code> <code>Union[str, bool]</code> <p>State to change to can be \"on\" or \"off\" / True or False</p> required <p>Returns:</p> Name Type Description <code>String</code> <code>str</code> <p>A string for the request</p> Source code in <code>src/pyvlcb/__init__.py</code> <pre><code>def accessory_command (self, node_id: int, ev_id: int, state: Union[str, bool]) -&gt; str:\n    \"\"\"Create an accessory command\n\n    Uses appropriate Accessory On / Off command\n    Defaulting to short, but using long if &gt; 0xffff\n\n    Args:\n        node_id: Node ID to query\n        ev_id: Event ID\n        state: State to change to can be \"on\" or \"off\" / True or False\n\n    Returns:\n        String: A string for the request\n    \"\"\"\n    # if ev_id is a string then convert to an int\n    # Setting based to 0 will automatically handle base 10 or hex\n    ev_id = int(ev_id, 0)\n    # determine if long or short\n    if ev_id &lt;= 0xffff:\n        return self.accessory_short_command (node_id, ev_id, state)\n    else:\n        return self.accessory_long_command (node_id, ev_id, state)\n</code></pre>"},{"location":"reference/#pyvlcb.VLCB.accessory_long_command","title":"<code>accessory_long_command(node_id, ev_id, state)</code>","text":"<p>Create an accessory long command</p> <p>Uses ACON (90) or ACOF (91)</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>Node ID to query</p> required <code>ev_id</code> <code>int</code> <p>Event ID</p> required <code>state</code> <code>Union[str, bool]</code> <p>State to change to can be \"on\" or \"off\" / True or False</p> required <p>Returns:</p> Name Type Description <code>String</code> <code>str</code> <p>A string for the request</p> Source code in <code>src/pyvlcb/__init__.py</code> <pre><code>def accessory_long_command (self, node_id: int, ev_id: int, state: Union[str, bool]) -&gt; str:\n    \"\"\"Create an accessory long command\n\n    Uses ACON (90) or ACOF (91)\n\n    Args:\n        node_id: Node ID to query\n        ev_id: Event ID\n        state: State to change to can be \"on\" or \"off\" / True or False\n\n    Returns:\n        String: A string for the request\n    \"\"\"\n    # Turn on\n    if state == True or state == \"on\":\n        # ASON\n        return f\"{self.make_header(opcode='90')}90{num_to_4hexstr(ev_id)};\"\n    # Turn off = ASOFF\n    else:\n        return f\"{self.make_header(opcode='91')}91{num_to_4hexstr(ev_id)};\"\n</code></pre>"},{"location":"reference/#pyvlcb.VLCB.accessory_short_command","title":"<code>accessory_short_command(node_id, ev_id, state)</code>","text":"<p>Create an accessory short command</p> <p>Uses ASON (98) or ASOF (99)</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>Node ID to query</p> required <code>ev_id</code> <code>int</code> <p>Event ID</p> required <code>state</code> <code>Union[str, bool]</code> <p>State to change to can be \"on\" or \"off\" / True or False</p> required <p>Returns:</p> Name Type Description <code>String</code> <code>str</code> <p>A string for the request</p> Source code in <code>src/pyvlcb/__init__.py</code> <pre><code>def accessory_short_command (self, node_id: int, ev_id: int, state: Union[str, bool]) -&gt; str:\n    \"\"\"Create an accessory short command\n\n    Uses ASON (98) or ASOF (99)\n\n    Args:\n        node_id: Node ID to query\n        ev_id: Event ID\n        state: State to change to can be \"on\" or \"off\" / True or False\n\n    Returns:\n        String: A string for the request\n    \"\"\"\n    # Turn on\n    if state == True or state == \"on\":\n        # ASON\n        return f\"{self.make_header(opcode='98')}98{num_to_2hexstr(node_id)}{num_to_2hexstr(ev_id)};\"\n    # Turn off = ASOFF\n    else:\n        return f\"{self.make_header(opcode='99')}99{num_to_2hexstr(node_id)}{num_to_2hexstr(ev_id)};\"\n</code></pre>"},{"location":"reference/#pyvlcb.VLCB.allocate_loco","title":"<code>allocate_loco(loco_id, long=True)</code>","text":"<p>Create an allocate loco request</p> <p>Uses RLOC (40)</p> <p>Parameters:</p> Name Type Description Default <code>loco_id</code> <code>int</code> <p>Loco ID (long or short number)</p> required <code>long</code> <code>Optional[bool]</code> <p>Long loco ID (True) or short loco ID (False)</p> <code>True</code> <p>Returns:</p> Name Type Description <code>String</code> <code>str</code> <p>A string for the request</p> Source code in <code>src/pyvlcb/__init__.py</code> <pre><code>def allocate_loco (self, loco_id: int, long: Optional[bool] = True) -&gt; str:\n    \"\"\"Create an allocate loco request\n\n    Uses RLOC (40)\n\n    Args:\n        loco_id: Loco ID (long or short number)\n        long: Long loco ID (True) or short loco ID (False)\n\n    Returns:\n        String: A string for the request\n    \"\"\"\n    # Generate RLOC to allocate loco to a session\n    if long == False and loco_id &gt;= 127:\n        raise ValueError (\"Invalid short code. Loco ID {loco_id} is larger than 127\")\n    if long == True:\n        loco_id = loco_id | 0xC000\n    return f\"{self.make_header(opcode='40')}40{num_to_2hexstr(loco_id)};\"\n</code></pre>"},{"location":"reference/#pyvlcb.VLCB.discover","title":"<code>discover()</code>","text":"<p>Create a discovery string </p> <p>Uses op-code QNN (0D)</p> <p>Returns:</p> Name Type Description <code>String</code> <code>str</code> <p>A string for the request</p> Source code in <code>src/pyvlcb/__init__.py</code> <pre><code>def discover (self) -&gt; str:\n    \"\"\"Create a discovery string \n\n    Uses op-code QNN (0D)\n\n    Returns:\n        String: A string for the request\n    \"\"\"\n    # Return QNN \n    return self.make_header(opcode='0D') + '0D;'\n</code></pre>"},{"location":"reference/#pyvlcb.VLCB.discover_evn","title":"<code>discover_evn(node_id)</code>","text":"<p>Create a discover number of events for a node</p> <p>Uses op-code RQEVN (58)</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>Node ID to query</p> required <p>Returns:</p> Name Type Description <code>String</code> <code>str</code> <p>A string for the request</p> Source code in <code>src/pyvlcb/__init__.py</code> <pre><code>def discover_evn (self, node_id: int) -&gt; str:\n    \"\"\"Create a discover number of events for a node\n\n    Uses op-code RQEVN (58)\n\n    Args:\n        node_id (int): Node ID to query\n\n    Returns:\n        String: A string for the request\n    \"\"\"\n    return f\"{self.make_header(opcode='58')}58{num_to_2hexstr(node_id)};\" \n</code></pre>"},{"location":"reference/#pyvlcb.VLCB.discover_nerd","title":"<code>discover_nerd(node_id)</code>","text":"<p>Create a discover stored events for a node</p> <p>Uses op-code NERD (57)</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>Node ID to query</p> required <p>Returns:</p> Name Type Description <code>String</code> <code>str</code> <p>A string for the request</p> Source code in <code>src/pyvlcb/__init__.py</code> <pre><code>def discover_nerd (self, node_id: int) -&gt; str:\n    \"\"\"Create a discover stored events for a node\n\n    Uses op-code NERD (57)\n\n    Args:\n        node_id (int): Node ID to query\n\n    Returns:\n        String: A string for the request\n    \"\"\"\n    return f\"{self.make_header(opcode='57')}57{num_to_2hexstr(node_id)};\"\n</code></pre>"},{"location":"reference/#pyvlcb.VLCB.discover_nevn","title":"<code>discover_nevn(node_id)</code>","text":"<p>Create a discover number of events available for a node</p> <p>Uses op-code NNEVN (56)</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>Node ID to query</p> required <p>Returns:</p> Name Type Description <code>String</code> <code>str</code> <p>A string for the request</p> Source code in <code>src/pyvlcb/__init__.py</code> <pre><code>def discover_nevn (self, node_id: int) -&gt; str:\n    \"\"\"Create a discover number of events available for a node\n\n    Uses op-code NNEVN (56)\n\n    Args:\n        node_id (int): Node ID to query\n\n    Returns:\n        String: A string for the request\n    \"\"\"\n    return f\"{self.make_header(opcode='56')}56{num_to_2hexstr(node_id)};\"\n</code></pre>"},{"location":"reference/#pyvlcb.VLCB.keep_alive","title":"<code>keep_alive(session_id)</code>","text":"<p>Create an keep alive request</p> <p>For any loco allocated send a keep alive at least every 4 seconds Uses DKEEP (23)</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>int</code> <p>Session ID </p> required <p>Returns:</p> Name Type Description <code>String</code> <code>str</code> <p>A string for the request</p> Source code in <code>src/pyvlcb/__init__.py</code> <pre><code>def keep_alive (self, session_id: int) -&gt; str:\n    \"\"\"Create an keep alive request\n\n    For any loco allocated send a keep alive at least every 4 seconds\n    Uses DKEEP (23)\n\n    Args:\n        session_id: Session ID \n\n    Returns:\n        String: A string for the request\n    \"\"\"\n    return f\"{self.make_header(opcode='23')}23{num_to_1hexstr(session_id)};\"\n</code></pre>"},{"location":"reference/#pyvlcb.VLCB.loco_set_dfun","title":"<code>loco_set_dfun(session_id, byte1, byte2)</code>","text":"<p>Create a set function request</p> <p>Uses DFUN (60)</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>int</code> <p>Session ID</p> required <code>byte1</code> <code>bytes</code> <p>Function group. 1 = F1 to F4, 2 = F5 to F8, 3 = F9 to F12, 4 = F13 to 19, 5 = F20 to F28</p> required <code>byte2</code> <code>bytes</code> <p>1 bit per function 1=on, 0=off. LSB to right eg 1 = 0001, 2 = 0010</p> required <p>Returns:</p> Name Type Description <code>String</code> <code>str</code> <p>A string for the request</p> Source code in <code>src/pyvlcb/__init__.py</code> <pre><code>def loco_set_dfun (self, session_id: int, byte1: bytes, byte2: bytes) -&gt; str:\n    \"\"\"Create a set function request\n\n    Uses DFUN (60)\n\n    Args:\n        session_id: Session ID\n        byte1: Function group. 1 = F1 to F4, 2 = F5 to F8, 3 = F9 to F12, 4 = F13 to 19, 5 = F20 to F28\n        byte2: 1 bit per function 1=on, 0=off. LSB to right eg 1 = 0001, 2 = 0010\n\n    Returns:\n        String: A string for the request\n    \"\"\"\n    return f\"{self.make_header(opcode='60')}60{num_to_1hexstr(session_id)}{num_to_1hexstr(byte1)}{num_to_1hexstr(byte2)};\"\n</code></pre>"},{"location":"reference/#pyvlcb.VLCB.loco_set_function","title":"<code>loco_set_function(session_id, function_num, function_list)</code>","text":"<p>Create a set function request using the function list Sends the entire group of functions where the function_num resides This is an alternative to loco_set_dfun as this calculates the bytes this method can only be used for functions 0 to 27</p> <p>Uses DFUN (60)</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>int</code> <p>Session ID</p> required <code>byte1</code> <p>Function number</p> required <code>byte2</code> <p>List of current function statuses</p> required <p>Returns:</p> Name Type Description <code>String</code> <code>str</code> <p>A string for the request</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Typically raised from f_to_bytes</p> Source code in <code>src/pyvlcb/__init__.py</code> <pre><code>def loco_set_function (self, session_id: int, function_num, function_list) -&gt; str:\n    \"\"\"Create a set function request using the function list\n    Sends the entire group of functions where the function_num resides\n    This is an alternative to loco_set_dfun as this calculates the bytes\n    this method can only be used for functions 0 to 27\n\n    Uses DFUN (60)\n\n    Args:\n        session_id: Session ID\n        byte1: Function number\n        byte2: List of current function statuses\n\n    Returns:\n        String: A string for the request\n\n    Raises:\n        ValueError: Typically raised from f_to_bytes\n    \"\"\"\n    byte1_2 = f_to_bytes(function_num, function_list)\n    return f\"{self.make_header(opcode='60')}60{num_to_1hexstr(session_id)}{byte1_2[0]}{byte1_2[1]};\"\n</code></pre>"},{"location":"reference/#pyvlcb.VLCB.loco_speed_dir","title":"<code>loco_speed_dir(session_id, speed, direction)</code>","text":"<p>Set loco speed and direction based on separate arguments</p> <p>Same as loco_speeddir but this takes 2 arguments, whereas loco_speeddir needs a combined value Maximum call this once every 32 milliseconds</p> <p>Uses DSPD (47)</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>int</code> <p>Session ID</p> required <code>speed</code> <code>int</code> <p>0 to 127 (1 is increased to 2 to avoid emergency stop)</p> required <code>direction</code> <code>int</code> <p>1 = forward, 0 = reverse</p> required <p>Returns:</p> Name Type Description <code>String</code> <code>str</code> <p>A string for the request</p> Source code in <code>src/pyvlcb/__init__.py</code> <pre><code>def loco_speed_dir (self, session_id: int, speed: int, direction: int) -&gt; str:\n    \"\"\"Set loco speed and direction based on separate arguments\n\n    Same as loco_speeddir but this takes 2 arguments, whereas loco_speeddir needs a combined value\n    Maximum call this once every 32 milliseconds\n\n    Uses DSPD (47)\n\n    Args:\n        session_id: Session ID\n        speed: 0 to 127 (1 is increased to 2 to avoid emergency stop)\n        direction: 1 = forward, 0 = reverse\n\n    Returns:\n        String: A string for the request\n\n    Raises:\n        ValueError is speed is out of range, or invalid direction\n    \"\"\"\n    if speed &lt; 0 or speed &gt; 127:\n        raise ValueError (\"Invalid speed specified. Must be in range 0 to 127\")\n    if direction &lt;0 or direction &gt; 1:\n        raise ValueError (\"Direction is not valid. Use 1 for forward, 0 for reverse\")\n    # special case - ignore emergency stop\n    if speed == 1:\n        speed = 2\n    speeddir = (direction * 0x80) + speed\n    return self.loco_speeddir (session_id, speeddir)\n</code></pre>"},{"location":"reference/#pyvlcb.VLCB.loco_speeddir","title":"<code>loco_speeddir(session_id, speeddir)</code>","text":"<p>Set loco speed and direction</p> <p>Maximum call this once every 32 milliseconds Needs combined speed and direction value. If speed is set to 1 then that is considered an emergency stop</p> <p>Uses DSPD (47)</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>int</code> <p>Session ID</p> required <code>speeddir</code> <code>int</code> <p>Unsigned 8 bit number. MSB is direction, 7 bits for speed</p> required <p>Returns:</p> Name Type Description <code>String</code> <code>str</code> <p>A string for the request</p> Source code in <code>src/pyvlcb/__init__.py</code> <pre><code>def loco_speeddir (self, session_id: int, speeddir: int) -&gt; str:\n    \"\"\"Set loco speed and direction\n\n    Maximum call this once every 32 milliseconds\n    Needs combined speed and direction value.\n    If speed is set to 1 then that is considered an emergency stop\n\n    Uses DSPD (47)\n\n    Args:\n        session_id: Session ID\n        speeddir: Unsigned 8 bit number. MSB is direction, 7 bits for speed\n\n    Returns:\n        String: A string for the request\n    \"\"\"\n    return f\"{self.make_header(opcode='47')}47{num_to_1hexstr(session_id)}{num_to_1hexstr(speeddir)};\"\n</code></pre>"},{"location":"reference/#pyvlcb.VLCB.loco_stop_all","title":"<code>loco_stop_all()</code>","text":"<p>Create an emergency stop all locos</p> <p>Uses op-code RESTP (0A)</p> <p>Returns:</p> Name Type Description <code>String</code> <code>str</code> <p>A string for the request</p> Source code in <code>src/pyvlcb/__init__.py</code> <pre><code>def loco_stop_all (self) -&gt; str:\n    \"\"\"Create an emergency stop all locos\n\n    Uses op-code RESTP (0A)\n\n    Returns:\n        String: A string for the request\n    \"\"\"\n    return f\"{self.make_header(opcode='0A')}0A;\"\n</code></pre>"},{"location":"reference/#pyvlcb.VLCB.log_entry","title":"<code>log_entry(input_string)</code>","text":"<p>Parse a log entry and return as a list of string values</p> <p>Parameters:</p> Name Type Description Default <code>input_string</code> <code>string</code> <p>String consisting of of num, date, direction, message as a single string</p> required <p>Returns (list[str]): List of strings</p> Source code in <code>src/pyvlcb/__init__.py</code> <pre><code>def log_entry(self, input_string: str) -&gt; list[str]:\n    \"\"\"Parse a log entry and return as a list of string values\n\n    Args:\n        input_string (string): String consisting of of num, date, direction, message as a single string\n\n    Returns (list[str]): List of strings\n\n    \"\"\"\n    # First remove number and date from the front of the string\n    entry_parts = input_string.split(',', 3)\n    date_string = entry_parts[1]\n    direction = entry_parts[2]\n    message = entry_parts[3]\n    vlcb_entry = self.parse_input (message)\n    # Error handling of invalid packet\n    if vlcb_entry == False:\n        return [message, \"??\", \"\", \"Invalid data\"]\n    # convert op-code to string\n    # opcode is first two chars of data\n    opcode = vlcb_entry.data[0:2]\n    opcode_string = f'{opcode} - {VLCBOpcode.opcode_mnemonic(opcode)}'\n    #data_string = f\"{VLCBOpcode.parse_data(vlcb_entry.data)}\"\n    data_string = dict_to_string(VLCBOpcode.parse_data(vlcb_entry.data))\n    return [date_string, direction, message, str(vlcb_entry.can_id), opcode_string, data_string]\n</code></pre>"},{"location":"reference/#pyvlcb.VLCB.make_header","title":"<code>make_header(majpri=2, minpri=None, can_id=None, opcode=None)</code>","text":"<p>Create a CBUS/VLCB header</p> <p>Parameters:</p> Name Type Description Default <code>byte1</code> <code>byte</code> <p>Most significant byte</p> required <code>byte2</code> <code>byte</code> <p>Least significant byte</p> required <p>Returns:</p> Name Type Description <code>String</code> <code>str</code> <p>A hex representation of the number</p> Source code in <code>src/pyvlcb/__init__.py</code> <pre><code>def make_header(self, \n            majpri: int = 0b10, \n            minpri: Optional[int] = None, \n            can_id: Optional[int] = None, \n            opcode: Optional[int] = None) -&gt; str:\n    \"\"\"Create a CBUS/VLCB header\n\n    Args:\n        byte1 (byte): Most significant byte\n        byte2 (byte): Least significant byte\n\n    Returns:\n        String: A hex representation of the number\n    \"\"\"\n    if can_id == None:\n        can_id = self.can_id\n\n    if minpri == None and opcode != None:\n        minpri = VLCBOpcode.opcode_priority(opcode)\n\n    # If opcode not updated then use default low priority\n    # Lower number is higher priority\n    if minpri == None:\n        minpri = 0b11\n\n    header_val = (majpri &lt;&lt; 14) + (minpri &lt;&lt; 12) + (can_id &lt;&lt; 5)\n    header_to_hex = (\"000\" + hex(header_val).upper()[2:])[-4:]\n    header_string = f':S{header_to_hex}N'\n    return header_string\n</code></pre>"},{"location":"reference/#pyvlcb.VLCB.parse_input","title":"<code>parse_input(input_bytes)</code>","text":"<p>Parse a raw CBUS packet as an input bytestring</p> <p>Take a bytestring (or string) from the CBUS and extract the details</p> <p>Parameters:</p> Name Type Description Default <code>input_types</code> <code>bytestring</code> <p>Input raw bytestring (or string)</p> required <p>Returns:</p> Name Type Description <code>VLCBFormat</code> <code>VLCBFormat</code> <p>parsed data in VLCBFormat</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If invalid data string</p> Source code in <code>src/pyvlcb/__init__.py</code> <pre><code>def parse_input(self, input_bytes: bytes) -&gt; VLCBFormat:\n    \"\"\"Parse a raw CBUS packet as an input bytestring\n\n    Take a bytestring (or string) from the CBUS and extract the details\n\n    Args: \n        input_types (bytestring): Input raw bytestring (or string)\n\n    Returns:\n        VLCBFormat: parsed data in VLCBFormat\n\n    Raises:\n        ValueError: If invalid data string\n\n    \"\"\"\n    # Also allow string (no need to decode)\n    if isinstance (input_bytes, str):\n        input_string = input_bytes\n    else:\n        input_string = input_bytes.decode(\"utf-8\")\n    if (len(input_string) &lt; 5):        # packets are actually much longer\n        raise ValueError(f\"input_bytes '{input_string}' is too short.\")\n    if (input_string[0] != \":\"):\n        raise ValueError(f\"No start frame in '{input_string}'\")\n    if (input_string[1] != \"S\"):\n        raise ValueError(\"Format not supported - only Standard frames allowed in {input_string}\")\n    # Use try when converting to number in case of error\n    try:\n        header = input_string[2:6]\n        header_val = int(header, 16)\n    except:\n        raise ValueError(f\"Invalid format, number expected {header}\")\n        header_val = 0\n    logger.debug (f\"Header {hex(header_val)}\")\n    priority = (header_val &amp; 0xf000) &gt;&gt; 12\n    logger.debug (f\"Priority {priority:b}\")\n    can_id = (header_val &amp; 0xfe0) &gt;&gt; 5\n    logger.debug(f\"Can ID {can_id}\")\n    # Next is N / RTR can be ignored\n    logger.debug(f\"N / RTR {input_string[6]}\")\n    # Data is rest excluding ; \n    data = input_string[7:-1]\n    logger.debug(f\"Data {data}\")\n    # Creates a VLCB_format and returns that\n    return VLCBFormat (priority, can_id, data)\n</code></pre>"},{"location":"reference/#pyvlcb.VLCB.release_loco","title":"<code>release_loco(session_id)</code>","text":"<p>Create a release loco request</p> <p>Uses KLOC (21)</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>int</code> <p>Session number</p> required <p>Returns:</p> Name Type Description <code>String</code> <code>str</code> <p>A string for the request</p> Source code in <code>src/pyvlcb/__init__.py</code> <pre><code>def release_loco (self, session_id: int) -&gt; str:\n    \"\"\"Create a release loco request\n\n    Uses KLOC (21)\n\n    Args:\n        session_id: Session number\n\n    Returns:\n        String: A string for the request\n    \"\"\"\n    return f\"{self.make_header(opcode='21')}21{num_to_1hexstr(session_id)};\"\n</code></pre>"},{"location":"reference/#pyvlcb.VLCB.share_loco","title":"<code>share_loco(loco_id, long=True)</code>","text":"<p>Create an share loco request</p> <p>Takes the loco and other connectons to the loco can remain. Uses GLOC (61)</p> <p>Parameters:</p> Name Type Description Default <code>loco_id</code> <code>int</code> <p>Loco ID (long or short number)</p> required <code>long</code> <code>Optional[bool]</code> <p>Long loco ID (True) or short loco ID (False)</p> <code>True</code> <p>Returns:</p> Name Type Description <code>String</code> <code>str</code> <p>A string for the request</p> Source code in <code>src/pyvlcb/__init__.py</code> <pre><code>def share_loco (self, loco_id: int, long: Optional[bool] = True) -&gt; str:\n    \"\"\"Create an share loco request\n\n    Takes the loco and other connectons to the loco can remain.\n    Uses GLOC (61)\n\n    Args:\n        loco_id: Loco ID (long or short number)\n        long: Long loco ID (True) or short loco ID (False)\n\n    Returns:\n        String: A string for the request\n\n    Raises:\n        InvalidLocoError\n    \"\"\"\n    # GLOC 61 - flag = 1 for steal, flag = for share\n    if long == False and loco_id &gt;= 127:\n        raise InvalidLocoError(f\"Invalid short code {loco_id}\")\n    if long == True:\n        loco_id = loco_id | 0xC000\n    return f\"{self.make_header(opcode='61')}61{num_to_2hexstr(loco_id)}02;\" \n</code></pre>"},{"location":"reference/#pyvlcb.VLCB.steal_loco","title":"<code>steal_loco(loco_id, long=True)</code>","text":"<p>Create an steal loco request</p> <p>Takes the loco and other connectons to the loco should be terminated.       Uses GLOC (60)</p> <p>Parameters:</p> Name Type Description Default <code>loco_id</code> <code>int</code> <p>Loco ID (long or short number)</p> required <code>long</code> <code>Optional[bool]</code> <p>Long loco ID (True) or short loco ID (False)</p> <code>True</code> <p>Returns:</p> Name Type Description <code>String</code> <code>str</code> <p>A string for the request</p> Source code in <code>src/pyvlcb/__init__.py</code> <pre><code>def steal_loco (self, loco_id: int, long: Optional[bool] = True) -&gt; str:\n    \"\"\"Create an steal loco request\n\n    Takes the loco and other connectons to the loco should be terminated.        \n    Uses GLOC (60)\n\n    Args:\n        loco_id: Loco ID (long or short number)\n        long: Long loco ID (True) or short loco ID (False)\n\n    Returns:\n        String: A string for the request\n\n    Raises:\n        InvalidLocoError\n    \"\"\"\n    # GLOC 61 - flag = 1 for steal, flag = for share\n    if long == False and loco_id &gt;= 127:\n        raise InvalidLocoError(f\"Invalid short code {loco_id}\")\n    if long == True:\n        loco_id = loco_id | 0xC000\n    return f\"{self.make_header(opcode='61')}61{num_to_2hexstr(loco_id)}01;\"   \n</code></pre>"},{"location":"reference/#pyvlcb.CanUSB4.__init__","title":"<code>__init__(port, baud=115200, timeout=0.01, exclusive=True)</code>","text":"<p>Inits CanUSB4 with a USB port</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>USB port eg. /dev/ttyACM0 (RPi)</p> required <code>baud</code> <code>Optional[int]</code> <p>Baud rate in bytes</p> <code>115200</code> <code>timeout</code> <code>Optional[float]</code> <p>How long to wait for a serial timeout (seconds)</p> <code>0.01</code> <p>Raises:</p> Type Description <code>DeviceConnectionError</code> <p>If the port cannot be opened or is already in use.</p> <code>InvalidConfigurationError</code> <p>If the port name is empty or invalid.</p> Source code in <code>src/pyvlcb/canusb.py</code> <pre><code>def __init__ (self, \n              port: str, \n              baud: Optional[int] = 115200, \n              timeout: Optional[float] = 0.01,\n              exclusive: Optional[bool] = True) -&gt; None:\n    \"\"\"Inits CanUSB4 with a USB port\n\n    Args:\n        port: USB port eg. /dev/ttyACM0 (RPi)\n        baud: Baud rate in bytes\n        timeout: How long to wait for a serial timeout (seconds)\n\n    Raises:\n        DeviceConnectionError: If the port cannot be opened or is already in use.\n        InvalidConfigurationError: If the port name is empty or invalid.\n\n    \"\"\"\n    self.debug = False\n    self.port = port\n    self.baud = baud\n    self.timeout = timeout\n    self.max_retry = 30    # How many times to attempt on get_data must be at least as long as frame\n    # Timeout for a request could be max_rety x timeout\n    self.exclusive = exclusive\t# Exclusive determines if check for exclusive use of the USB port\n    # If this is set to false then if another application is already using the port then the application\n    # will run, but appear to hang if there is no response because another thread has already\n    # taken the incoming data\n\n    if not port:\n        raise InvalidConfigurationError(\"Port name cannot be empty\")\n\n    # buffer to hold partial string - allows us to continue if read ends partway through a packet\n    self.current_buffer = ''\n    # Track if we are in a valid string (ie. ignore any data outside of : ; blocks\n    self.data_start = False\n    self.connect()\n</code></pre>"},{"location":"reference/#pyvlcb.CanUSB4.connect","title":"<code>connect(port=None, baud=None, timeout=None, exclusive=None)</code>","text":"<p>Inits CanUSB4 with a USB port</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>Optional[str]</code> <p>USB port eg. /dev/ttyACM0 (RPi)</p> <code>None</code> <code>baud</code> <code>Optional[int]</code> <p>Baud rate in bytes</p> <code>None</code> <code>timeout</code> <code>Optional[float]</code> <p>How long to wait for a serial timeout (seconds)</p> <code>None</code> <p>Raises:</p> Type Description <code>DeviceConnectionError</code> <p>If the port cannot be opened or is already in use.</p> <code>InvalidConfigurationError</code> <p>If the port name is empty or invalid.</p> Source code in <code>src/pyvlcb/canusb.py</code> <pre><code>def connect(self,\n            port: Optional[str] = None,\n            baud: Optional[int] = None,\n            timeout: Optional[float] = None,\n            exclusive: Optional[bool] = None) -&gt; None:\n    \"\"\"Inits CanUSB4 with a USB port\n\n    Args:\n        port: USB port eg. /dev/ttyACM0 (RPi)\n        baud: Baud rate in bytes\n        timeout: How long to wait for a serial timeout (seconds)\n\n    Raises:\n        DeviceConnectionError: If the port cannot be opened or is already in use.\n        InvalidConfigurationError: If the port name is empty or invalid.\n\n    \"\"\"\n    if port != None:\n        self.port = port\n    if not self.port:\n        raise InvalidConfigurationError(\"Port name cannot be empty\")\n    if baud != None:\n        self.baud = baud\n    if timeout != None:\n        self.timeout = timeout\n    if exclusive != None:\n        self.exclusive = exclusive\n    try:\n        self.ser = serial.Serial(\n            self.port,\n            self.baud,\n            timeout=self.timeout,\n            exclusive = exclusive\n            )\n    except serial.SerialException as e:\n        raise DeviceConnectionError(f\"Could not open port {self.port}\") from e\n    if self.ser:\n        logger.info(\"Connected to serial port\")\n</code></pre>"},{"location":"reference/#pyvlcb.CanUSB4.read_data","title":"<code>read_data()</code>","text":"<p>Read data from CanUSB4</p> <p>Returns:</p> Name Type Description <code>List</code> <code>List[str]</code> <p>List of strings for all data read</p> <p>Raises:</p> Type Description <code>DeviceConnectionError</code> <p>Error receiving data - possible connection list</p> Source code in <code>src/pyvlcb/canusb.py</code> <pre><code>def read_data(self) -&gt; List[str]:\n    \"\"\"Read data from CanUSB4\n\n    Returns:\n        List: List of strings for all data read\n\n    Raises:\n        DeviceConnectionError: Error receiving data - possible connection list\n\n\n    \"\"\"\n\n    num_bytes = self.ser.in_waiting\n    # As each data string is read then it is stored into this list\n    # Which allows all new packets to be returned\n    received_data = []\n    if num_bytes &gt; 1:\n        try:\n            in_chars = self.ser.read(num_bytes)\n        except serial.SerialException as e:\n            raise DeviceConnectionError(\"Connection lost during read\") from e\n        # Unable to communicate with USB\n        # Any other error\n        except Exception as e:\n            raise DeviceConnectionError(\"Unable to read other error\") from e\n\n\n        for i in range(0, len(in_chars)):\n            this_char = chr(in_chars[i])\n            # End of packet\n            if this_char == ';':\n                # Check we have some data if not then ignore\n                if len(self.current_buffer) == 0:\n                    continue\n                # Add the terminating char\n                self.current_buffer += this_char\n                logger.debug (f\"Read {self.current_buffer}\")\n                received_data.append(self.current_buffer)\n                # delete the data\n                self.current_buffer = ''\n                # no longer inside a data packet\n                self.data_start = False\n            # Start of packet (resets string even if previous data)\n            elif this_char == ':':\n                self.data_start = True\n                self.current_buffer = ':'\n            # Only add character if we are inside a data block\n            elif self.data_start == True:\n                self.current_buffer += this_char\n            # If not then we are not in data block\n            else:\n                continue\n    return received_data    \n</code></pre>"},{"location":"reference/#pyvlcb.CanUSB4.send_data","title":"<code>send_data(data)</code>","text":"<p>Send data to serial</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, bytes]</code> <p>Data to send, normally from a VLCB method</p> required <p>Raises:</p> Type Description <code>InvalidConfigurationError</code> <p>If string contains invalid characters</p> <code>TypeError</code> <p>If data passed is not a string or a bytestring</p> <code>DeviceConnectionError</code> <p>Error sending data - possible connection lost</p> Source code in <code>src/pyvlcb/canusb.py</code> <pre><code>def send_data(self, data: Union[str, bytes]) -&gt; None:\n    \"\"\"Send data to serial\n\n    Args:\n        data: Data to send, normally from a VLCB method\n\n    Raises:\n        InvalidConfigurationError: If string contains invalid characters\n        TypeError: If data passed is not a string or a bytestring\n        DeviceConnectionError: Error sending data - possible connection lost\n    \"\"\"\n    logger.debug(f\"Sending {data}\")\n    if isinstance(data, str):\n        try:\n            # Convert string to bytes\n            payload = data.encode('ascii') # using ascii which is more restrictive than default \"utf-8\"\n        except UnicodeEncodeError as e:\n            raise InvalidConfigurationError(f\"String contains invalid characters: {data}\") from e\n    elif isinstance(data, bytes):\n        # It's already bytes, just use it\n        payload = data\n    else:\n        # User sent an int, list, or something else weird\n        raise TypeError(f\"Expected str or bytes, got {type(data).__name__}\")\n\n    # Send payload which is now bytes\n    try:\n        self.ser.write(payload)\n    except serial.SerialException as e:\n        raise DeviceConnectionError(\"Connection lost during write\") from e\n</code></pre>"},{"location":"reference/#pyvlcb.VLCBFormat.__init__","title":"<code>__init__(priority, can_id, data)</code>","text":"<p>Inits VLCBformat</p> <p>Parameters:</p> Name Type Description Default <code>priority</code> <code>int</code> <p>CAN priority</p> required <code>can_id</code> <code>int</code> <p>CAN ID</p> required <code>data</code> <code>str</code> <p>Remaining data as a hex string</p> required Source code in <code>src/pyvlcb/vlcbformat.py</code> <pre><code>def __init__ (self, priority: int, can_id: int, data: str) -&gt; None:\n    \"\"\"Inits VLCBformat\n\n    Args:\n        priority: CAN priority\n        can_id: CAN ID\n        data: Remaining data as a hex string\n\n    \"\"\"\n    self.priority = priority # Priority is actually high and low priority (2bit high / 2bit low) but just treated as single value\n    self.can_id = can_id\n    self.data = data # Data is left as hex string\n</code></pre>"},{"location":"reference/#pyvlcb.VLCBFormat.format_data","title":"<code>format_data()</code>","text":"<p>Returns the opcode associated with the data string</p> <p>Returns:</p> Name Type Description <code>OpcodeData</code> <code>OpcodeData</code> <p>Dict from the VLCBOpcode</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If opcode not found</p> Source code in <code>src/pyvlcb/vlcbformat.py</code> <pre><code>def format_data (self) -&gt; OpcodeData:\n    \"\"\"Returns the opcode associated with the data string\n\n    Returns:\n        OpcodeData: Dict from the VLCBOpcode\n\n    Raises:\n        ValueError: If opcode not found\n    \"\"\"\n    return VLCBOpcode.parse_data(self.data)\n</code></pre>"},{"location":"reference/#pyvlcb.VLCBFormat.get_data","title":"<code>get_data()</code>","text":"<p>Returns the opcode associated with the data string as a dict</p> <p>Returns:</p> Name Type Description <code>OpcodeData</code> <code>OpcodeData</code> <p>Dict from the VLCBOpcode</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If opcode not found</p> Source code in <code>src/pyvlcb/vlcbformat.py</code> <pre><code>def get_data (self) -&gt; OpcodeData:\n    \"\"\"Returns the opcode associated with the data string as a dict\n\n    Returns:\n        OpcodeData: Dict from the VLCBOpcode\n\n    Raises:\n        ValueError: If opcode not found\n    \"\"\"\n    return VLCBOpcode.parse_data(self.data)\n</code></pre>"},{"location":"reference/#pyvlcb.VLCBFormat.get_function_list","title":"<code>get_function_list()</code>","text":"<p>Where packet contains Fn1, Fn2, Fn3 (eg. PLOC) returns </p> <p>Only valid with certain VLCBFormat packets associated with Locos. If packet is does not contain the 3 byte values (which may be formatted differently) then raises a InvalidFunctionError</p> <p>Returns:</p> Type Description <code>List[int]</code> <p>List of function values as 0 or 1 for each function as off and on</p> <p>Raises:</p> Type Description <code>InvalidFunctionError</code> <p>If Function Bytes are not in the packet</p> Source code in <code>src/pyvlcb/vlcbformat.py</code> <pre><code>def get_function_list (self) -&gt; List[int]:\n    \"\"\"Where packet contains Fn1, Fn2, Fn3 (eg. PLOC)\n    returns \n\n    Only valid with certain VLCBFormat packets associated with Locos.\n    If packet is does not contain the 3 byte values (which\n    may be formatted differently) then raises a InvalidFunctionError\n\n    Returns:\n        List of function values as 0 or 1 for each function as off and on\n\n    Raises:\n        InvalidFunctionError: If Function Bytes are not in the packet\n    \"\"\"\n    if self.opcode() == \"PLOC\":\n        # Get data\n        data_dict = VLCBOpcode.parse_data(self.data)\n        return bytes_to_functions (data_dict['Fn1'], data_dict['Fn2'], data_dict['Fn3'])\n    else:\n        raise InvalidLocoError(f\"Opcode {self.opcode()} does not contain a loco_id\")\n</code></pre>"},{"location":"reference/#pyvlcb.VLCBFormat.get_loco_id","title":"<code>get_loco_id()</code>","text":"<p>Converts AddrHigh and AddrLow into a loco_id</p> <p>Only valid with certain VLCBFormat packets associated with Locos. If packet is does not contain the AddrHigh &amp; AddrLow values (which may be formatted differently) then raises a InvalidLocoError</p> <p>Returns:</p> Name Type Description <code>loco_id</code> <code>int</code> <p>Loco number</p> <p>Raises:</p> Type Description <code>InvalidLocoError</code> <p>If AddrHigh / AddrLow are not in the packet</p> Source code in <code>src/pyvlcb/vlcbformat.py</code> <pre><code>def get_loco_id (self) -&gt; int:\n    \"\"\"Converts AddrHigh and AddrLow into a loco_id\n\n    Only valid with certain VLCBFormat packets associated with Locos.\n    If packet is does not contain the AddrHigh &amp; AddrLow values (which\n    may be formatted differently) then raises a InvalidLocoError\n\n    Returns:\n        loco_id: Loco number\n\n    Raises:\n        InvalidLocoError: If AddrHigh / AddrLow are not in the packet\n    \"\"\"\n    loco_id = None\n    if self.opcode() == \"PLOC\":\n        # Get data\n        data_dict = VLCBOpcode.parse_data(self.data)\n        loco_id = data_dict['AddrHigh_AddrLow'] &amp; 0x3FFF\n    elif self.opcode() == \"ERR\":\n        # also check it's one of the Error codes associated with allocate loco etc.\n        # 1 = loco stack full 2 = loco taken, 7 = invalid request\n        # The following are not supported as data bytes contain session / consist ID and not loco_id\n        # 3 = no session, 4 consist empty, 5 loco not found, 6 can bus error\n        data_dict = VLCBOpcode.parse_data(self.data)\n        if data_dict[\"ErrCode\"] in [1, 2, 7]:\n            loco_id = bytes_to_addr(data_dict['Byte1'],data_dict['Byte2']) &amp; 0x3FFF\n        else:\n            raise InvalidLocoError (f\"Error code {data_dict['ErrCode']} does not contain a loco_id\")\n\n    # If loco_id not updated then raise error\n    if loco_id != None:\n        return loco_id\n    else:\n        raise InvalidLocoError(f\"Opcode {self.opcode()} does not contain a loco_id\")\n</code></pre>"},{"location":"reference/#pyvlcb.VLCBFormat.opcode","title":"<code>opcode()</code>","text":"<p>Returns the opcode associated with the data string</p> <p>Returns:</p> Type Description <p>Dictionary of the opcode data</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If opcode not found</p> Source code in <code>src/pyvlcb/vlcbformat.py</code> <pre><code>def opcode (self): # -&gt; Dict[str,str]:\n    \"\"\"Returns the opcode associated with the data string\n\n    Returns:\n        Dictionary of the opcode data\n\n    Raises:\n        ValueError: If opcode not found\n    \"\"\"\n    str_value = self.data[0:2]\n    if str_value in VLCBOpcode.opcodes.keys():\n        return VLCBOpcode.opcodes[str_value]['opc']\n    else:\n        raise ValueError(f\"Opcode {str_value} is not defined.\")\n</code></pre>"},{"location":"reference/#pyvlcb.VLCBOpcode.opcode_extract","title":"<code>opcode_extract(opcode_string)</code>  <code>staticmethod</code>","text":"<p>Shortens op code by removing extra characters</p> <p>Returns:</p> Name Type Description <code>String</code> <code>str</code> <p>shortened opcode string</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If string does not contain at least 2 characters</p> Source code in <code>src/pyvlcb/vlcbformat.py</code> <pre><code>@staticmethod\ndef opcode_extract (opcode_string: str) -&gt; str:\n    \"\"\"Shortens op code by removing extra characters\n\n    Returns:\n        String: shortened opcode string\n\n    Raises:\n        ValueError: If string does not contain at least 2 characters\n    \"\"\"\n    if len(opcode_string) &gt;= 2:\n        return opcode_string[0:2]\n    else:\n        raise ValueError(f\"String {opcode_string} is too short.\")\n</code></pre>"},{"location":"reference/#pyvlcb.VLCBOpcode.opcode_mnemonic","title":"<code>opcode_mnemonic(opcode)</code>  <code>staticmethod</code>","text":"<p>Get mnemonic from opcode</p> <p>Returns:</p> Name Type Description <code>String</code> <p>Opcode mnemonic</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If opcode not found</p> Source code in <code>src/pyvlcb/vlcbformat.py</code> <pre><code>@staticmethod\ndef opcode_mnemonic (opcode):\n    \"\"\"Get mnemonic from opcode\n\n    Returns:\n        String: Opcode mnemonic\n\n    Raises:\n        ValueError: If opcode not found\n    \"\"\"\n    opcode = VLCBOpcode.opcode_extract(opcode)\n    if opcode in VLCBOpcode.opcodes.keys():\n        return VLCBOpcode.opcodes[opcode]['opc']\n    else:\n        raise ValueError(f\"Opcode {opcode} is not defined.\")\n</code></pre>"},{"location":"reference/#pyvlcb.VLCBOpcode.opcode_priority","title":"<code>opcode_priority(opcode)</code>  <code>staticmethod</code>","text":"<p>Get priority from opcode</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>priority value</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If opcode not found</p> Source code in <code>src/pyvlcb/vlcbformat.py</code> <pre><code>@staticmethod\ndef opcode_priority (opcode: str) -&gt; int:\n    \"\"\"Get priority from opcode\n\n    Returns:\n        int: priority value\n\n    Raises:\n        ValueError: If opcode not found\n    \"\"\"\n    opcode = VLCBOpcode.opcode_extract(opcode)\n    if opcode in VLCBOpcode.opcodes.keys():\n        return VLCBOpcode.opcodes[opcode]['minpri']\n    else:\n        raise ValueError(f\"Opcode {opcode} is not defined.\")\n</code></pre>"},{"location":"reference/#pyvlcb.VLCBOpcode.opcode_title","title":"<code>opcode_title(opcode)</code>  <code>staticmethod</code>","text":"<p>Get title from opcode</p> <p>Returns:</p> Name Type Description <code>String</code> <code>str</code> <p>Opcode Title</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If opcode not found</p> Source code in <code>src/pyvlcb/vlcbformat.py</code> <pre><code>@staticmethod\ndef opcode_title (opcode: str) -&gt; str:\n    \"\"\"Get title from opcode\n\n    Returns:\n        String: Opcode Title\n\n    Raises:\n        ValueError: If opcode not found\n    \"\"\"\n    opcode = VLCBOpcode.opcode_extract(opcode)\n    if opcode in VLCBOpcode.opcodes.keys():\n        return VLCBOpcode.opcodes[opcode]['title']\n    else:\n        raise ValueError(f\"Opcode {opcode} is not defined.\")\n</code></pre>"},{"location":"reference/#pyvlcb.VLCBOpcode.parse_data","title":"<code>parse_data(data)</code>  <code>staticmethod</code>","text":"<p>Returns the data associated with the data string as a dict</p> <p>Returns:</p> Name Type Description <code>OpcodeData</code> <code>OpcodeData</code> <p>Dict in OpcodeData format</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If opcode not found</p> Source code in <code>src/pyvlcb/vlcbformat.py</code> <pre><code>@staticmethod\ndef parse_data (data: str) -&gt; OpcodeData:\n    \"\"\"Returns the data associated with the data string as a dict\n\n    Returns:\n        OpcodeData: Dict in OpcodeData format\n\n    Raises:\n        ValueError: If opcode not found\n    \"\"\"\n    # Does not raise any explicit exceptions but uses methods that could raise a ValueError\n    opcode = VLCBOpcode.opcode_extract(data)\n    # strip opcode from data\n    data = data[2:]\n\n    #print (f\"Data {data}\")\n    # Include opcode in data if required for future use\n    data_parsed = {'opid': opcode}\n    # check valid opcode (if not then empty format)\n    if not opcode in VLCBOpcode.opcodes.keys():\n        format = \"\"\n        data_parsed['opcode'] = \"UNKNOWN\"\n    else:\n        format = VLCBOpcode.opcodes[opcode]['format']\n        data_parsed['opcode'] = VLCBOpcode.opcodes[opcode]['opc']\n    format_fields = format.split(',')\n    # Remove data as added to dict so when reach 0 we are complete\n    # parse each of the fields\n    for this_field in format_fields:\n        # If no format then skip and add any data at end\n        if this_field == \"\":\n            break\n        # If unknown then flag here - should only get this during unittests if a new format is added\n        if this_field not in VLCBOpcode.field_formats.keys():\n            logging.warning (f\"Warning format field {this_field} not recognised\")\n            this_field = \"Unknown\"\n        # Take number of bytes from remaining data\n        # Check enough first - if not then add warning\n        num_chars = VLCBOpcode.field_formats[this_field][0] \n        if len(data) &lt; num_chars :\n            data_parsed[this_field] = f\"Insufficient data {data}\"\n            # remove remaining\n            data = \"\"\n        else:\n            # Move number of chars (typically 2 chars per byte) into this_val\n            this_val = data[0:num_chars]\n            data = data[num_chars:]\n            # if number expected then convert\n            if VLCBOpcode.field_formats[this_field][1] != \"char\":\n                this_val = int(this_val, 16)\n            data_parsed[this_field] = this_val\n    # remaining data added to final field (shouldn't normally get this)\n    if len(data) &gt; 0:\n        data_parsed[\"ExtraData\"] = data\n    return data_parsed\n</code></pre>"},{"location":"reference/#pyvlcb.utils.bytes_to_addr","title":"<code>bytes_to_addr(byte1, byte2)</code>","text":"<p>Convert 2 byte values into an address id sring</p> <p>Parameters:</p> Name Type Description Default <code>byte1</code> <code>bytes</code> <p>Most significant byte</p> required <code>byte2</code> <code>bytes</code> <p>Least significant byte</p> required <p>Returns:</p> Name Type Description <code>Int</code> <code>int</code> <p>The address id value</p> Source code in <code>src/pyvlcb/utils.py</code> <pre><code>def bytes_to_addr (byte1: bytes, byte2: bytes) -&gt; int:\n    \"\"\"Convert 2 byte values into an address id sring\n\n    Args:\n        byte1 (bytes): Most significant byte\n        byte2 (bytes): Least significant byte\n\n    Returns:\n        Int: The address id value\n    \"\"\"\n    msb = int(byte1)\n    lsb = int(byte2)\n    return ((msb &lt;&lt; 8) + lsb)\n</code></pre>"},{"location":"reference/#pyvlcb.utils.bytes_to_functions","title":"<code>bytes_to_functions(fn1, fn2, fn3)</code>","text":"<p>Sets the value of the functions from a PLOC message Only returns values for F0 to F12 (others not included in PLOC) Provides as a list for inclusion in menus etc.</p> <p>Parameters:</p> Name Type Description Default <code>fn1</code> <code>bytes</code> <p>Function byte F0 to F4 - bit 5 = dir lighting (F0), bit 6 = direction, bit 7 = res, bit 8 = 0</p> required <code>fn2</code> <code>bytes</code> <p>Function byte F5 to F8 - bit 5 upwards reserved</p> required <code>fn3</code> <code>bytes</code> <p>Function byte F9 to F12</p> required <p>Returns:</p> Type Description <code>List[int]</code> <p>List of function values as 0 or 1 for each function as off and on</p> Source code in <code>src/pyvlcb/utils.py</code> <pre><code>def bytes_to_functions (fn1: bytes, fn2: bytes, fn3: bytes) -&gt; List[int]:\n    \"\"\" Sets the value of the functions from a PLOC message\n    Only returns values for F0 to F12 (others not included in PLOC)\n    Provides as a list for inclusion in menus etc.\n\n    Args:\n        fn1: Function byte F0 to F4 - bit 5 = dir lighting (F0), bit 6 = direction, bit 7 = res, bit 8 = 0\n        fn2: Function byte F5 to F8 - bit 5 upwards reserved\n        fn3: Function byte F9 to F12\n\n    Returns:\n        List of function values as 0 or 1 for each function as off and on\n\n    \"\"\"    \n    data_in = [fn1, fn2, fn3]\n    mask = [0b0001, 0b0010, 0b0100, 0b1000]\n    function_status = [0] * 29\n    # Handle 0 separately as it's in the upper nibble\n    function_status[0] = data_in[0] &amp; 0b10000\n    # Create a list of 12 entries\n    for i in range (0, 3):\n        for j in range (0, 4):\n            function_status[(i*4)+j+1] = 1 if (data_in[i] &amp; mask[j]) &gt; 0 else 0\n\n    return function_status\n</code></pre>"},{"location":"reference/#pyvlcb.utils.bytes_to_hexstr","title":"<code>bytes_to_hexstr(byte1, byte2)</code>","text":"<p>Convert 2 bytes to a hex string</p> <p>Parameters:</p> Name Type Description Default <code>byte1</code> <code>bytes</code> <p>Most significant byte</p> required <code>byte2</code> <code>bytes</code> <p>Least significant byte</p> required <p>Returns:</p> Name Type Description <code>String</code> <code>str</code> <p>A hex representation of the number</p> Source code in <code>src/pyvlcb/utils.py</code> <pre><code>def bytes_to_hexstr (byte1: bytes, byte2: bytes) -&gt; str:\n    \"\"\"Convert 2 bytes to a hex string\n\n    Args:\n        byte1 (bytes): Most significant byte\n        byte2 (bytes): Least significant byte\n\n    Returns:\n        String: A hex representation of the number\n    \"\"\"\n    return f\"{hex(byte1).upper()[2:]:0&gt;2}{hex(byte2).upper()[2:]:0&gt;2}\"\n</code></pre>"},{"location":"reference/#pyvlcb.utils.dict_to_string","title":"<code>dict_to_string(dictionary)</code>","text":"<p>Convert a dict to a string without {} or quotes</p> Source code in <code>src/pyvlcb/utils.py</code> <pre><code>def dict_to_string (dictionary: dict) -&gt; str:\n    \"\"\" Convert a dict to a string without {} or quotes \"\"\"\n    data_string = \"\"\n    for key, value in dictionary.items():\n        if data_string != \"\":\n            data_string += \" , \"\n        data_string += f\"{key} = {value}\"\n    return data_string\n</code></pre>"},{"location":"reference/#pyvlcb.utils.f_to_bytes","title":"<code>f_to_bytes(f_num, function_status)</code>","text":"<p>Convert a Fnumber (Loco function ID) to bytes as string representation</p> <p>Can be used to create correct format for loco_set_dfun Limited to range 0 to 28 - which is max for DFUN Higher would need to use DFNON/DFOFF</p> <p>Parameters:</p> Name Type Description Default <code>f_num</code> <code>int</code> <p>Function number</p> required <code>function_status</code> <code>List[int]</code> <p>List with value of all functions (must be updated before calling)</p> required <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>Tuple of two x 2-characer strings representing the bytes</p> <p>Raises: ValueError</p> Source code in <code>src/pyvlcb/utils.py</code> <pre><code>def f_to_bytes (f_num: int, function_status: List[int]) -&gt; Tuple[str, str]:\n    \"\"\" Convert a Fnumber (Loco function ID) to bytes as string representation\n\n    Can be used to create correct format for loco_set_dfun\n    Limited to range 0 to 28 - which is max for DFUN\n    Higher would need to use DFNON/DFOFF\n\n    Args:\n        f_num: Function number\n        function_status: List with value of all functions (must be updated before calling)\n\n    Returns:\n        Tuple of two x 2-characer strings representing the bytes\n\n    Raises: ValueError\n\n    \"\"\"\n    # Must be an F number between 0 and 28\n    if f_num &lt; 0 or f_num &gt; 28:\n        raise ValueError (f\"Fnumber needs to be between 0 and 28. Number provided {f_num}\")\n\n    # Extend function_status to 29 entries\n    function_list = function_status + [0] * (29 - len(function_status))\n\n    if f_num &lt;= 4:\n        byte1 = 1\n        byte2 = (0b10000 * function_list[0] +  # fn0 is higher nibble (bit 5)\n                 0b0001 * function_list[1] +\n                 0b0010 * function_list[2] +\n                 0b0100 * function_list[3] +\n                 0b1000 * function_list[4]\n                 )\n    elif f_num &lt;= 8:\n        byte1 = 2\n        byte2 = (0b0001 * function_list[5] +\n                 0b0010 * function_list[6] +\n                 0b0100 * function_list[7] +\n                 0b1000 * function_list[8]\n                 )\n    elif f_num &lt;= 12:\n        byte1 = 3\n        byte2 = (0b0001 * function_list[9] +\n                 0b0010 * function_list[10] +\n                 0b0100 * function_list[11] +\n                 0b1000 * function_list[12]\n                 )\n    elif f_num &lt;= 20:\n        byte1 = 4\n        byte2 = (0b0001 * function_list[13] +\n                 0b0010 * function_list[14] +\n                 0b0100 * function_list[15] +\n                 0b1000 * function_list[16] +\n                 0b10000 * function_list[17] +\n                 0b100000 * function_list[18] +\n                 0b1000000 * function_list[19] +\n                 0b10000000 * function_list[20]\n                 )\n    elif f_num &lt;= 28:\n        byte1 = 5\n        byte2 = (0b0001 * function_list[21] +\n                 0b0010 * function_list[22] +\n                 0b0100 * function_list[23] +\n                 0b1000 * function_list[24] +\n                 0b10000 * function_list[25] +\n                 0b100000 * function_list[26] +\n                 0b1000000 * function_list[27] +\n                 0b10000000 * function_list[28]\n                 )\n    # convert to strings before returning\n    # and with 0xFF guarentees it doesn't overflow (although not really neccessary for this method)\n    str1 = f\"{ (byte1 &amp; 0xFF) :02x}\"\n    str2 = f\"{ (byte2 &amp; 0xFF) :02x}\"\n    return (str1, str2)\n</code></pre>"},{"location":"reference/#pyvlcb.utils.num_to_1hexstr","title":"<code>num_to_1hexstr(num)</code>","text":"<p>Convert number to a byte</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>int</code> <p>Number to convert</p> required <p>Returns:</p> Name Type Description <code>String</code> <code>str</code> <p>A hex representation of the number (2 chars)</p> Source code in <code>src/pyvlcb/utils.py</code> <pre><code>def num_to_1hexstr (num: int) -&gt; str:\n    \"\"\"Convert number to a byte\n\n    Args:\n        num (int): Number to convert\n\n    Returns:\n        String: A hex representation of the number (2 chars)\n    \"\"\"\n    return f\"{hex(num).upper()[2:]:0&gt;2}\"\n</code></pre>"},{"location":"reference/#pyvlcb.utils.num_to_2hexstr","title":"<code>num_to_2hexstr(num)</code>","text":"<p>Convert number to 2 bytes</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>int</code> <p>Number to convert</p> required <p>Returns:</p> Name Type Description <code>String</code> <code>str</code> <p>A hex representation of the number (4 chars)</p> Source code in <code>src/pyvlcb/utils.py</code> <pre><code>def num_to_2hexstr (num: int) -&gt; str:\n    \"\"\"Convert number to 2 bytes\n\n    Args:\n        num (int): Number to convert\n\n    Returns:\n        String: A hex representation of the number (4 chars)\n    \"\"\"\n    return f\"{hex(num).upper()[2:]:0&gt;4}\"\n</code></pre>"},{"location":"reference/#pyvlcb.utils.num_to_4hexstr","title":"<code>num_to_4hexstr(num)</code>","text":"<p>Convert number to 4 bytes</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>int</code> <p>Number to convert</p> required <p>Returns:</p> Name Type Description <code>String</code> <code>str</code> <p>A hex representation of the number (8 chars)</p> Source code in <code>src/pyvlcb/utils.py</code> <pre><code>def num_to_4hexstr (num: int) -&gt; str:\n    \"\"\"Convert number to 4 bytes\n\n    Args:\n        num (int): Number to convert\n\n    Returns:\n        String: A hex representation of the number (8 chars)\n    \"\"\"\n    return f\"{hex(num).upper()[2:]:0&gt;8}\"\n</code></pre>"},{"location":"spec/","title":"VLCB protocol specification","text":"<p>Details of the VLCB specification as implemented within the PyVLCB library</p> <p>This is intended as an overview only, where the specification differs from the official VLCB standards, then the VLCB documentation should take precedent.</p>"},{"location":"spec/#vlcb-opcodes","title":"VLCB Opcodes","text":"<p>These are the opcodes listed in the VLCBOpcode.opcodes dictionary.</p> OpCode '00' (0) Name ACK Title General Acknowledgement Args / data None Priority 2 Description Positive response to query/request performed for report of availability online OpCode '01' (1) Name NAK Title General No Ack Args / data None Priority 2 Description Negative response to query/request denied OpCode '02' (2) Name HLT Title Bus Halt Args / data None Priority 0 Description Commonly broadcasted to all nodes to indicate CBUS is not available and no further packets should be sent until a BON or ARST is received OpCode '03' (3) Name BON Title Bus On Args / data None Priority 1 Description Commonly broadcasted to all nodes to indicate CBUS is available following a HLT. OpCode '04' (4) Name TOF Title Track Off Args / data None Priority 1 Description Commonly broadcasted to all nodes by a command station to indicate track power is off and no further command packets should be sent, except inquiries.. OpCode '05' (5) Name TON Title Track On Args / data None Priority 1 Description Commonly broadcasted to all nodes by a command station to indicate track power is on. OpCode '06' (6) Name ERSTOP Title Emergency Stop Args / data None Priority 1 Description Commonly broadcase to all nodes by a command station to indicate all engines have been emergency stopped. OpCode '07' (7) Name ARST Title System Reset Args / data None Priority 0 Description Commonly broadcasted to all nodes to indicate a full system reset. OpCode '08' (8) Name RTOF Title Request Track Off Args / data None Priority 1 Description Sent to request change of track power to off. OpCode '09' (9) Name RTON Title Request Track On Args / data None Priority 1 Description Sent to request change of track power to on. OpCode '0A' (10) Name RESTP Title Request Emergency Stop All Args / data None Priority 0 Description Sent to request an emergency stop to all trains . Does not affect accessory control. OpCode '0C' (12) Name RSTAT Title Request Command Station Status Args / data None Priority 2 Description Sent to query the status of the command station. See description of (STAT) for the response from the command station. OpCode '0D' (13) Name QNN Title Query node number Args / data None Priority 3 Description Sent by a node to elicit a PNN reply from each node on the bus that has a node number. See OpCode 0xB6 OpCode '10' (16) Name RQNP Title Request node parameters Args / data None Priority 3 Description Sent to a node while in ?setup?mode to read its parameter set. Used when initially configuring a node. OpCode '11' (17) Name RQMN Title Request module name Args / data None Priority 2 Description Sent by a node to request the name of the type of module that is in setup mode. The module in setup mode will reply with opcode NAME. See OpCode 0xE2 OpCode '21' (33) Name KLOC Title Release Engine Args / data Session Priority 2 Description Sent by a CAB to the Command Station. The engine with that Session number is removed from the active engine list. OpCode '22' (34) Name QLOC Title Query Engine Args / data Session Priority 2 Description The command station responds with PLOC if the session is assigned. Otherwise responds with ERR: engine not found. OpCode '23' (35) Name DKEEP Title Session keep alive Args / data Session Priority 2 Description The cab sends a keep alive at regular intervals for the active session. The interval between keep alive messages must be less than the session timeout implemented by the command station. OpCode '30' (48) Name DBG1 Title Debug with one data byte Args / data Status Priority 2 Description  is a freeform status byte for debugging during CBUS module development. Not used during normal operation OpCode '3F' (63) Name EXTC Title Extended op-code with no additional bytes Args / data ExtOpc Priority 3 Description Used if the basic set of 32 OPCs is not enough. Allows an additional 256 OPCs OpCode '40' (64) Name RLOC Title Request engine session Args / data AddrHigh_AddrLow Priority 2 Description The command station responds with (PLOC) if engine is free and is being assigned. Otherwise responds with (ERR): engine in use or (ERR:) stack full. This command is typically sent by a cab to the command station following a change of the controlled decoder address. RLOC is exactly equivalent to GLOC with all flag bits set to zero, but command stations must continue to support RLOC for backwards compatibility. OpCode '41' (65) Name QCON Title Query Consist Args / data Consist,Index Priority 2 Description Allows enumeration of a consist. Command station responds with PLOC if an engine exists at the specified index, otherwise responds with ERR: no more engines OpCode '42' (66) Name SNN Title Set Node Number Args / data NN Priority 3 Description Sent by a configuration tool to assign a node number to a requesting node in response to a RQNN message. The target node must be in ?setup? mode. OpCode '43' (67) Name ALOC Title Allocate loco to activity Args / data Session,AllocCode Priority 2 Description None OpCode '44' (68) Name STMOD Title Set CAB session mode Args / data Session,Mode Priority 2 Description MMMMMMMM = mode bits: 0 ? 1: speed mode; 00 ? 128 speed steps; 01 ? 14 speed steps; 10 ? 28 speed steps with interleave steps; 11 ? 28 speed steps; 2: service mode; 3: sound control mode OpCode '45' (69) Name PCON Title Consist Engine Args / data Session,Consist Priority 2 Description Adds a decoder to a consist. Dat2 has bit 7 set if consist direction is reversed. OpCode '46' (70) Name KCON Title Remove Engine from consist Args / data Session,Consist Priority 2 Description Removes a loco from a consist. OpCode '47' (71) Name DSPD Title Set Engine Speed/Dir Args / data Session,SpeedDir Priority 0 Description the unsigned speed value. Sent by a CAB or equivalent to request an engine speed/dir change. OpCode '48' (72) Name DFLG Title Set Engine Flags Args / data Session,SpeedFlag Priority 2 Description Bits 0-1: Speed Mode 00 ? 128 speed steps; 01 ? 14 speed steps; 10 ? 28 speed steps with interleave steps; 11 ? 28 speed steps Bit 2: Lights On/OFF; Bit 3: Engine relative direction; Bits 4-5: Engine state (active =0 , consisted =1, consist master=2, inactive=3) Bits 6-7: Reserved.; Sent by a cab to notify the command station of a change in engine flags. OpCode '49' (73) Name DFNON Title Set Engine function on Args / data Session,Fnum Priority 2 Description Sent by a cab to turn on a specific loco function. This provides an alternative method to DFUN for controlling loco functions. A command station must implement both methods. OpCode '4C' (76) Name SSTAT Title Service mode status Args / data Session,Status Priority 3 Description Status returned by command station/programmer at end of programming operation that does not return data. OpCode '50' (80) Name RQNN Title Request node number Args / data NN Priority 3 Description Sent by a node that is in setup/configuration mode and requests assignment of a node number (NN). The node allocating node numbers responds with (SNN) which contains the newly assigned node number.  and  are the existing node number, if the node has one. If it does not yet have a node number, these bytes should be set to zero. OpCode '51' (81) Name NNREL Title Node number release Args / data NN Priority 3 Description Sent by node when taken out of service. e.g. when reverting to SLiM mode. OpCode '52' (82) Name NNACK Title Node number acknowledge Args / data NN Priority 3 Description Sent by a node to verify its presence and confirm its node id. This message is sent to acknowledge an SNN. OpCode '53' (83) Name NNLRN Title Set node into learn mode Args / data NN Priority 3 Description Sent by a configuration tool to put a specific node into learn mode. Deprecated - replaced by MODE OpCode '54' (84) Name NNULN Title Release node from learn mode Args / data NN Priority 3 Description Sent by a configuration tool to take node out of learn mode and revert to normal operation. OpCode '55' (85) Name NNCLR Title Clear all events from a node Args / data NN Priority 3 Description Sent by a configuration tool to clear all events from a specific node. Must be in learn mode first to safeguard against accidental erasure of all events. OpCode '56' (86) Name NNEVN Title Read number of events available in a node Args / data NN Priority 3 Description Sent by a configuration tool to read the number of available event slots in a node.Response is EVLNF (0x70) OpCode '57' (87) Name NERD Title Read back all stored events in a node Args / data NN Priority 3 Description Sent by a configuration tool to read all the stored events in a node. Response is 0xF2. OpCode '58' (88) Name RQEVN Title Request to read number of stored events Args / data NN Priority 3 Description Sent by a configuration tool to read the number of stored events in a node. Response is 0x74( NUMEV). OpCode '59' (89) Name WRACK Title Write acknowledge Args / data NN Priority 3 Description Sent by a node to indicate the completion of a write to memory operation. All nodes must issue WRACK when a write operation to node variables, events or event variables has completed. This allows for teaching nodes where the processing time may be slow. Deprecated replaced by GRSP OpCode '5A' (90) Name RQDAT Title Request node data event Args / data NN Priority 3 Description Sent by one node to read the data event from another node.(eg: RFID data). Response is 0xF7 (ARDAT). OpCode '5B' (91) Name RQDDS Title Request device data - short mode Args / data DNHigh_DNLow Priority 3 Description To request a data set from a device using the short event method. where DN is the device number. Response is 0xFB (DDRS) OpCode '5C' (92) Name BOOTM Title Put node into bootload mode Args / data NN Priority 3 Description For SliM nodes with no NN then the NN of the command must be zero. For SLiM nodes with an NN, and all FLiM nodes the command must contain the NN of the target node. Sent by a configuration tool to prepare for loading a new program. Deprecated replaced by MODE OpCode '5D' (93) Name ENUM Title Force a self enumeration cyble for use with CAN Args / data NN Priority 3 Description For nodes in FLiM using CAN as transport. This OPC will force a self-enumeration cycle for the specified node. A new CAN_ID will be allocated if needed. Following the ENUM sequence, the node should issue a NNACK to confirm completion and verify the new CAN_ID. If no CAN_ID values are available, an error message 7 will be issued instead. Deprecated replaced with automatic self enumeration. OpCode '5F' (95) Name EXTC1 Title Extended op-code with 1 additional byte Args / data ExtOpc,Byte1 Priority 3 Description Used if the basic set of 32 OPCs is not enough. Allows an additional 256 OPCs OpCode '60' (96) Name DFUN Title Set Engine functions Args / data Session,Fn1,Fn2 Priority 2 Description  (Fn1) is the function range. 1 is F0(FL) to F4; 2 is F5 to F8; 3 is F9 to F12; 4 is F13 to F20; 5 is F21 to F28;  (Fn2) is the NMRA DCC format function byte for that range in corresponding bits. Sent by a CAB or equivalent to request an engine Fn state change. OpCode '61' (97) Name GLOC Title Get engine session Args / data AddrHigh_AddrLow,Flags Priority 2 Description  and  are [AddrH] and [AddrL] of the decoder, respectively.; 7 bit addresses have (AddrH=0).; 14 bit addresses have bits 6,7 of AddrH set to 1.;  contains flag bits as follows:Bit 0: Set for \"Steal\" mode; Bit 1: Set for \"Share\" mode; Both bits set to 0 is exactly equivalent to an RLOC request; Both bits set to 1 is invalid, because the 2 modes are mutually exclusive; The command station responds with (PLOC) if the request is successful. Otherwise responds with (ERR): engine in use. (ERR:) stack full or (ERR) no session. The latter indicates that there is no current session to steal/share depending on the flag bits set in the request. GLOC with all flag bits set to zero is exactly equivalent to RLOC, but command stations must continue to support RLOC for backwards compatibility. OpCode '63' (99) Name ERR Title Command station error report Args / data Byte1,Byte2,ErrCode Priority 2 Description Sent in response to an error situation by a command station. OpCode '6F' (111) Name CMDERR Title Error messages from nodes during configuration Args / data NN,Error Priority 3 Description Sent by node if there is an error when a configuration command is sent. Deprecated replaced by GRSP. OpCode '70' (112) Name EVNLF Title Event space left reply from node Args / data NN,EVSPC Priority 3 Description EVSPC is a one byte value giving the number of available events left in that node. OpCode '71' (113) Name NVRD Title Request read of a node variable Args / data NN,NVIndex Priority 3 Description NV# is the index for the node variable value requested. Response is NVANS. VLCB also returns GRSP and support for NV#0. OpCode '72' (114) Name NENRD Title Request read of stored events by event index Args / data NN,EnIndex Priority 3 Description EN# is the index for the stored event requested. Response is 0xF2 (ENRSP) OpCode '73' (115) Name RQNPN Title Request read of a node parameter by index Args / data NN,ParaIndex Priority 3 Description Para# is the index for the parameter requested. Index 0 returns the number of available parameters, Response is 0x9B (PARAN). VLCB Para #0 returns a PARAN for each parameter OpCode '74' (116) Name NUMEV Title Number of events stored in node Args / data NN,NumEvents Priority 3 Description Response to request 0x58 (RQEVN) OpCode '75' (117) Name CANID Title Set a CAN_ID in existing FLiM node Args / data NN,CAN_ID Priority 0 Description Used to force a specified CAN_ID into a node. Value range is from 1 to 0x63 (99 decimal) This OPC must be used with care as duplicate CAN_IDs are not allowed. Values outside the permitted range will produce an error 7 message and the CAN_ID will not change. Deprecated replaced with self-enumaration. VLCB includes GRSP responses. OpCode '76' (118) Name MODE Title Request a change to a modules operating mode Args / data NN,ModeCmd Priority 0 Description Request to change the operational mode of the module. Mode cmds 0 = transition to setup mode, 1 = transition to normal mode, 16 = turn on FCU compat, 17 = turn off FCU compat. If supported then module returns GRSP. VLCB new features. OpCode '78' (120) Name RQSD Title Request service discover Args / data NN,ServiceIndex Priority 0 Description Request service data from a module if ServiceIndex is 0 then SD message sent, followed by ESD response for each services supported. VLCB new feature. OpCode '7F' (127) Name EXTC2 Title Extended op-code with 2 additional bytes Args / data ExtOpc,Byte1,Byte2 Priority 0 Description Used if the basic set of 32 OPCs is not enough. Allows an additional 256 OPCs OpCode '80' (128) Name RDCC3 Title Request 3-byte DCC Packet Args / data Rep,Byte1,Byte2,Byte3 Priority 3 Description  is number of repetitions in sending the packet. .. 3 bytes of the DCC packet. Allows a CAB or equivalent to request a 3 byte DCC packet to be sent to the track. The packet is sent  times and is not refreshed on a regular basis. Note: a 3 byte DCC packet is the minimum allowed. OpCode '82' (130) Name WCVO Title Write CV (byte) in OPS mode Args / data Session,CVHigh_CVLow,CVVal Priority 2 Description  is the session number of the loco to be written to;  is the MSB # of the CV to be written (supports CVs 1 - 65536);  is the LSB # of the CV to be written;  is the byte value to be written; Sent to the command station to write a DCC CV byte in OPS mode to specific loco.(on the main) OpCode '83' (131) Name WCVB Title Write CV (bit) in OPS mode Args / data Session,CVHigh_CVLow,CVVal Priority 2 Description  is the session number of the loco to be written to;  is the MSB # of the CV to be written (supports CVs 1 - 65536);  is the LSB # of the CV to be written;  is the value to be written; The format for Dat4 is that specified in RP 9.2.1 for OTM bit manipulation in a DCC packet.; This is ?111CDBBB? where C is here is always 1 as only ?writes? are possible OTM. (unless some loco ACK scheme like RailCom is used). D is the bit value, either 0 or 1 and BBB is the bit position in the CV byte. 000 to 111 for bits 0 to 7.; Sent to the command station to write a DCC CV in OPS mode to specific loco.(on the main) OpCode '84' (132) Name QCVS Title Read CV Args / data Session,CVHigh_CVLow,Mode Priority 2 Description This command is used exclusively with service mode.; Sent by the cab to the command station in order to read a CV value. The command station shall respond with a PCVS message containing the value read, or SSTAT if the CV cannot be read. OpCode '85' (133) Name PCVS Title Report CV Args / data Session,CVHigh_CVLow,CVVal Priority 2 Description  is the session number of the cab;  is the MSB # of the CV read (supports CVs 1 - 65536);  is the LSB # of the CV read;  is the read value; This command is used exclusively with service mode.; Sent by the command station to report a read CV. OpCode '87' (135) Name RDGN Title Request dianostic data Args / data NN,ServiceIndex,DiagCode Priority 0 Description Request diagnostic data from a module. If DiagCode is 0 then all data returned. If ServiceIndex 0 then send DGN message for each service, otherwise send DGN for service specified OpCode '8E' (142) Name NVSETRD Title Set an NV value with read back Args / data NN,NNIndex,NVVal Priority 0 Description Sets an NV value and responds with the new value, response may not be the value requested. VLCB new feature. OpCode '90' (144) Name ACON Title Accessory ON Args / data NN,EnHigh_EnLow Priority 3 Description  is the high byte of the node number;  is the low byte of the node number;  is the high byte of the event number;  is the low byte of the event number; Indicates an ?ON? event using the full event number of 4 bytes. (long event) OpCode '91' (145) Name ACOF Title Accessory OFF Args / data NN,EnHigh_EnLow Priority 3 Description  is the high byte of the node number;  is the low byte of the node number;  is the high byte of the event number;  is the low byte of the event number; Indicates an ?OFF? event using the full event number of 4 bytes. (long event) OpCode '92' (146) Name AREQ Title Accessory Request Event Args / data NN,EnHigh_EnLow Priority 3 Description  is the high byte of the node number (MS WORD of the full event #);  is the low byte of the node number (MS WORD of the full event #);  is the high byte of the event number;  is the low byte of the event number; Indicates a ?request? event using the full event number of 4 bytes. (long event); A request event is used to elicit a status response from a producer when it is required to know the state of the producer without producing an ON or OFF event and to trigger an event from a combi node OpCode '93' (147) Name ARON Title Accessory Response Event Args / data NN,EnHigh_EnLow Priority 3 Description Indicates an ?ON? response event. A response event is a reply to a status request (AREQ) without producing an ON or OFF event. OpCode '94' (148) Name AROF Title Accessory Response Event Args / data NN,EnHigh_EnLow Priority 3 Description  is the high byte of the node number;  is the low byte of the node number;  is the high byte of the event number;  is the low byte of the event number; Indicates an \u2018OFF\u2019 response event. A response event is a reply to a status request; (AREQ) without producing an ON or OFF event OpCode '95' (149) Name EVULN Title Unlearn an event in learn mode Args / data NN,EnHigh_EnLow Priority 3 Description Sent by a configuration tool to remove an event from a node. VLCB also return GRSP. OpCode '96' (150) Name NVSET Title Set a node variable Args / data NN,NVIndex,NVVal Priority 3 Description Sent by a configuration tool to set a node variable. NV# is the NV index number. Deprecated replaced by NVSETRD. VLCB also return GRSP. OpCode '97' (151) Name NVANS Title Response to a request for a node variable value Args / data NN,NVIndex,NVVal Priority 3 Description Sent by node in response to request. (NVRD) OpCode '98' (152) Name ASON Title Accessory short ON Args / data NN,DNHigh_DNLow Priority 3 Description Indicates an \u2018ON\u2019 event using the short event number of 2 LS bytes. OpCode '99' (153) Name ASOF Title Accessory short OFF Args / data NN,DNHigh_DNLow Priority 3 Description Indicates an \u2018OFF\u2019 event using the short event number of 2 LS bytes. OpCode '9A' (154) Name ASRQ Title Accessory Short Request Event Args / data NN,DNHigh_DNLow Priority 3 Description Indicates a \u2018request\u2019 event using the short event number of 2 LS bytes. A request event is used to elicit a response from a producer \u2018device\u2019 when it is required to know the \u2018state\u2019 of the device without producing an ON or OFF event and to trigger an event from a combi node. OpCode '9B' (155) Name PARAN Title Response to request for individual node parameter Args / data NN,ParaIndex,ParaVal Priority 3 Description NN is the node number of the sending node. Para# is the index of the parameter and Para val is the parameter value. OpCode '9C' (156) Name REVAL Title Request for read of an event variable Args / data NN,EnIndex,EvIndex Priority 3 Description This request differs from B2 (REQEV) as it doesn\u2019t need to be in learn mode but does; require the knowledge of the event index to which the EV request is directed.; EN# is the event index. EV# is the event variable index. Response is B5 (NEVAL) OpCode '9D' (157) Name ARSON Title Accessory short response event Args / data NN,DNHigh_DNLow Priority 3 Description Indicates an \u2018ON\u2019 response event. A response event is a reply to a status request (ASRQ) without producing an ON or OFF event. OpCode '9E' (158) Name ARSOF Title Accessory short response event Args / data NN,DNHigh_DNLow Priority 3 Description ndicates an \u2018OFF\u2019 response event. A response event is a reply to a status request (ASRQ) without producing an ON or OFF event. OpCode '9F' (159) Name EXTC3 Title Extended op-code with 3 additional bytes Args / data ExtOpc,Byte1,Byte2,Byte3 Priority 0 Description Used if the basic set of 32 OPCs is not enough. Allows an additional 256 OPCs OpCode 'A0' (160) Name RDCC4 Title Request 4-byte DCC packet Args / data Rep,Byte1,Byte2,Byte3,Byte4 Priority 2 Description  is number of repetitions in sending the packet.; .. 4 bytes of the DCC packet.; Allows a CAB or equivalent to request a 4 byte DCC packet to be sent to the track. The; packet is sent  times and is not refreshed on a regular basis. OpCode 'A2' (162) Name WCVS Title Write CV in Service Mode Args / data Session,CVHigh_CVLow,Mode,CVVal Priority 0 Description  is the session number of the cab;  is the MSB # of the CV to be written (supports CVs 1 - 65536);  is the LSB # of the CV to be written;  is the service write mode;  is the CV value to be written; Sent to the command station to write a DCC CV in service mode. OpCode 'AB' (171) Name HEARTB Title Heartbeat message from module Args / data NN,Sequence,Status,StatusBits Priority 0 Description Hearbeat message from module indicating alive. Sent every 5 seconds by module. Sequence count from 0, incrementing and wrap around to 0., Statis is binary representation of diagnostic status 0x00 is normal operation. StatusBits is reserved set to 0x00. VLCB new feature. OpCode 'AC' (172) Name SD Title Service discovery response Args / data NN,ServiceIndex,ServiceType,Version Priority 0 Description Version of service supported response to RQSD with ServiceIndex = 0. First SD response is number of following SD responses. Also see ESD. VLCB new feature. OpCode 'AF' (175) Name GRSP Title Generic response Args / data NN,Opcode,ServiceType,Result Priority 0 Description Generic response for a config change request. Result byte indicates ok for success or error code. CMDERR codes are supported. VLCB new feature. OpCode 'B0' (176) Name ACON1 Title Accessory ON Args / data NN,EnHigh_EnLow,Byte1 Priority 3 Description  is the high byte of the node number;  is the low byte of the node number;  is the high byte of the event number;  is the low byte of the event number;  is an additional data byte; Indicates an \u2018ON\u2019 event using the full event number of; 4 bytes with one additional data byte. OpCode 'B1' (177) Name ACOF1 Title Accessory OFF Args / data NN,EnHigh_EnLow,Byte1 Priority 3 Description  is the high byte of the node number;  is the low byte of the node number;  is the high byte of the event number;  is the low byte of the event number;  is an additional data byte; Indicates an \u2018OFF\u2019 event using the full event number of 4 bytes with one additional data byte. OpCode 'B2' (178) Name REQEV Title Read event variable in learn mode Args / data NN,EnHigh_EnLow,EvIndex Priority 3 Description Allows a configuration tool to read stored event variables from a node. EV# is the EV index. Reply is (EVANS) OpCode 'B3' (179) Name ARON1 Title Accessory Response Event Args / data NN,EnHigh_EnLow,Byte1 Priority 3 Description Indicates an \u2018ON\u2019 response event with one additional data byte. A response event is a reply to a status request (AREQ) without producing an ON or OFF event. OpCode 'B4' (180) Name AROF1 Title Accessory Response Event Args / data NN,EnHigh_EnLow,Byte1 Priority 3 Description Indicates an \u2018OFF\u2019 response event with one additional data byte. A response event is a reply to a status request (AREQ) without producing an ON or OFF event. OpCode 'B5' (181) Name NEVAL Title Response to request for read of EV value Args / data NN,EnIndex,EvIndex,EvVal Priority 3 Description NN is the node replying. EN# is the index of the event in that node. EV# is the index of the event variable. EVval is the value of that EV. This is response to 9C (REVAL) OpCode 'B6' (182) Name PNN Title Response to Query Node Args / data NN,ManufId,ModId,Flags Priority 3 Description  is the high byte of the node number;  is the low byte of the node number;  is the Manufacturer id as defined in the node parameters;  is the Module Type Id id as defined in the node parameters;  is the node flags as defined in the node parameters. The Flags byte contains bit flags as follows:; Bit 0: Set to 1 for consumer node; Bit 1: Set to 1 for producer node; Bit 2: Set to 1 for FLiM mode; Bit 3: Set to 1 for Bootloader compatible; If a module is both a producer and a consumer then it is referred to as a combi node and; both flags will be set.; Every node should send this message in response to a QNN message. OpCode 'B8' (184) Name ASON1 Title Accessory Short ON Args / data NN,DNHigh_DNLow,Byte1 Priority 3 Description Indicates an \u2018ON\u2019 event using the short event number of 2 LS bytes with one added data byte. OpCode 'B9' (185) Name ASOF1 Title Accessory Short OFF Args / data NN,DNHigh_DNLow,Byte1 Priority 3 Description Indicates an \u2018OFF\u2019 event using the short event number of 2 LS bytes with one added data byte. OpCode 'BD' (189) Name ARSON1 Title Accessory Short Response Event with one data byte Args / data NN,DNHigh_DNLow,Byte1 Priority 3 Description Indicates an \u2018ON\u2019 response event with one added data byte. A response event is a reply to a status request (ASRQ) without producing an ON or OFF event. OpCode 'BE' (190) Name ARSOF1 Title Accessory short response event with one data byte Args / data NN,DNHigh_DNLow,Byte1 Priority 3 Description Indicates an \u2018OFF\u2019 response event with one added data byte. A response event is a reply to a status request (ASRQ) without producing an ON or OFF event. OpCode 'BF' (191) Name EXTC4 Title Extended op-code with 4 data bytes Args / data ExtOpc,Byte1,Byte2,Byte3,Byte4 Priority 3 Description Used if the basic set of 32 OPCs is not enough. Allows an additional 256 OPCs. OpCode 'C0' (192) Name RDCC5 Title Requst 5-byte DCC packet Args / data Rep,Byte1,Byte2,Byte3,Byte4,Byte5 Priority 2 Description  is # of repetitions in sending the packet.; .. 5 bytes of the DCC packet.; Allows a CAB or equivalent to request a 5 byte DCC packet to be sent to the track. The packet is sent  times and is not refreshed on a regular basis. OpCode 'C1' (193) Name WCVOA Title Write CV (byte) in OPS mode by address Args / data AddrHigh_AddrLow,CVHigh_CVLow,Mode,CVVal Priority 2 Description  and  are [AddrH] and [AddrL] of the decoder, respectively.; 7 bit addresses have (AddrH=0).; 14 bit addresses have bits 7,8 of AddrH set to 1.;  is the MSB # of the CV to be written (supports CVs 1 - 65536);  is the LSB # of the CV to be written;  is the programming mode to be used;  is the CV byte value to be written; Sent to the command station to write a DCC CV byte in OPS mode to specific loco (on the main). Used by computer based ops mode programmer that does not have a valid throttle handle. OpCode 'C2' (194) Name CABDAT Title Send data to DCC CAB which is controlling loco Args / data AddrHigh_AddrLow,DataCode,Byte1,Byte2,Byte3 Priority 1 Description Send data to DCC CAB controlling particular loco. CABSIG data1 for aspect1, data2 for aspect2, data3 for speed. Defined in RFC0005. OpCode 'C7' (199) Name DGN Title Dianostic data resonse Args / data NN,ServiceIndex,DiagCode,DiagVal Priority 0 Description Diagnostic data value from a module sent in response to RDGN. VLCB new features OpCode 'CF' (207) Name FCLK Title Fast Clock Args / data DateTime Priority 3 Description This addendum defines a time encoding OpCode 'D0' (208) Name ACON2 Title Accessory ON Args / data NN,EnHigh_EnLow,Byte1,Byte2 Priority 3 Description Indicates an \u2018ON\u2019 event using the full event number of 4 bytes with two additional data bytes. OpCode 'D1' (209) Name ACOF2 Title Accessory OFF Args / data NN,EnHigh_EnLow,Byte1,Byte2 Priority 3 Description ndicates an \u2018OFF\u2019 event using the full event number of 4 bytes with two additional data bytes. OpCode 'D2' (210) Name EVLRN Title Teach an event in learn mode Args / data NN,EnHigh_EnLow,EvIndex,EvVal Priority 3 Description A node response to a request from a configuration tool for the EVs associated with an event (REQEV). For multiple EVs, there will be one response per request. VLCB also return GRSP. OpCode 'D3' (211) Name EVANS Title Response to a request for an EV value in a node in learn mode Args / data NN,EnHigh_EnLow,EvIndex,EvVal Priority 3 Description A node response to a request from a configuration tool for the EVs associated with an event (REQEV). For multiple EVs, there will be one response per request. OpCode 'D4' (212) Name ARON2 Title Accessory Response Event Args / data NN,EnHigh_EnLow,Byte1,Byte2 Priority 3 Description Indicates an \u2018ON\u2019 response event with two added data bytes. A response event is a reply to a status request (AREQ) without producing an ON or OFF event. OpCode 'D5' (213) Name AROF2 Title Accessory Response Event Args / data NN,EnHigh_EnLow,Byte1,Byte2 Priority 3 Description Indicates an \u2018OFF\u2019 response event with two added data bytes. A response event is a reply to a status request (AREQ) without producing an ON or OFF event. OpCode 'D8' (216) Name ASON2 Title Accessory Short ON Args / data NN,DNHigh_DNLow,Byte1,Byte2 Priority 3 Description Indicates an \u2018ON\u2019 event using the short event number of 2 LS bytes with two added data bytes. OpCode 'DD' (221) Name ARSON2 Title Accessory Short Response Event with two bytes Args / data NN,DNHigh_DNLow,Byte1,Byte2 Priority 3 Description Indicates an \u2018ON\u2019 response event with two added data bytes. A response event is a reply to a status request (ASRQ) without producing an ON or OFF event. OpCode 'DE' (222) Name ARSOF2 Title Accessory Short Response Event with two bytes Args / data NN,DNHigh_DNLow,Byte1,Byte2 Priority 3 Description Indicates an \u2018OFF\u2019 response event with two added data bytes. A response event is a reply to a status request (ASRQ) without producing an ON or OFF event. OpCode 'DF' (223) Name EXTC5 Title Extended op-code with 5 data bytes Args / data ExtOpc,Byte1,Byte2,Byte3,Byte4,Byte5 Priority 3 Description Used if the basic set of 32 OPCs is not enough. Allows an additional 256 OPCs OpCode 'E0' (224) Name RDCC6 Title Request 6 byte DCC packet Args / data Rep,Byte1,Byte2,Byte3,Byte4,Byte5 Priority 2 Description Allows a CAB or equivalent to request a 6 byte DCC packet to be sent to the track. The packet is sent  times and is not refreshed on a regular basis. OpCode 'E1' (225) Name PLOC Title Engine Report Args / data Session,AddrHigh_AddrLow,SpeedDir,Fn1,Fn2,Fn3 Priority 2 Description  is the Speed/Direction value. Bit 7 is the direction bit and bits 0-6 are the speed value.;  is the function byte F0 to F4;  is the function byte F5 to F8;  is the function byte F9 to F12; A report of an engine entry sent by the command station. Sent in response to QLOC or as an acknowledgement of acquiring an engine requested by a cab (RLOC or GLOC). OpCode 'E2' (226) Name NAME Title Response to request for node name string Args / data Char1_7 Priority 3 Description A node response while in \u2018setup\u2019 mode for its name string. Reply to (RQMN). The string for the module type is returned in char1 to char7, space filled to 7 bytes. The Module Name prefix , currently either CAN or ETH, depends on the Interface Protocol parameter, it is not included in the response, see section 12.2 for the definition of the parameters. OpCode 'E3' (227) Name STAT Title Command station status report Args / data NN,CSNum,Flags,MajRev,MinRev,Build Priority 2 Description  Gives node id of command station, so further info can be got from parameters or interrogating NVs;  For future expansion - set to zero at present;  Flags as defined below;  Major revision number;  Minor revision letter;  Build number, always 0 for a released version.;  is status defined by the bits below.; bits:; 0 - Hardware Error (self test); 1 - Track Error; 2 - Track On/ Off; 3 - Bus On/ Halted; 4 - EM. Stop all performed; 5 - Reset done; 6 - Service mode (programming) On/ Off; 7 \u2013 reserved; Sent by the command station in response to RSTAT. OpCode 'E7' (231) Name ESD Title Extended service discovery response Args / data NN,ServiceIndex,ServiceType,Byte1,Byte2,Byte3 Priority 0 Description Detailed information about a service supported by a module. Sent in response to RQSD where ServiceIndex is not 0. VLCB new feature OpCode 'E9' (233) Name DTXC Title Streaming protocol Args / data StreamID,Sequence,Byte1,Byte2,Byte3,Byte4,Byte5 Priority 0 Description Used to transport relatively large block of data. StreamID is unique layout wide (&gt; 20). If Sequence num is 0x00 then bytes are MessageLen (2 bytes), CRC16 (2 bytes), Flags (1 byte reserved). Defined in RFC0005 OpCode 'EF' (239) Name PARAMS Title Response to request for node parameters Args / data Para1_7 Priority 3 Description A node response while in \u2018setup\u2019 mode for its parameter string. Reply to (RQNP) OpCode 'F0' (240) Name ACON3 Title Accessory ON Args / data NN,EnHigh_EnLow,Byte1,Byte2,Byte3 Priority 3 Description Indicates an ON event using the full event number of 4 bytes with three additional data bytes. OpCode 'F1' (241) Name ACOF3 Title Accessory OFF Args / data NN,EnHigh_EnLow,Byte1,Byte2,Byte3 Priority 3 Description Indicates an OFF event using the full event number of 4 bytes with three additional data bytes. OpCode 'F2' (242) Name ENRSP Title Response to request to read node events Args / data NN,En3_0,EnIndex Priority 3 Description Where the NN is that of the sending node. EN3 to EN0 are the four bytes of the stored event. EN# is the index of the event within the sending node. This is a response to either 57 (NERD) or 72 (NENRD) OpCode 'F3' (243) Name ARON3 Title Acessory Response Event Args / data NN,EnHigh_EnLow,Byte1,Byte2,Byte3 Priority 3 Description Indicates an \u2018ON\u2019 response event with three added data bytes. A response event is a reply to a status request (AREQ) without producing an ON or OFF event. OpCode 'F4' (244) Name AROF3 Title Acessory Response Event Args / data NN,EnHigh_EnLow,Byte1,Byte2,Byte3 Priority 3 Description Indicates an \u2018ON\u2019 response event with three added data bytes. A response event is a reply to a status request (AREQ) without producing an ON or OFF event. OpCode 'F5' (245) Name EVLRNI Title Teach and event in learn mode using event indexing Args / data NN,EnHigh_EnLow,EnIndex,EvIndex,EvVal Priority 3 Description Sent by a configuration tool to a node in learn mode to teach it an event. The event index must be known. Also teaches it the associated event variables.(EVs). This command is repeated for each EV required. VLCB allow zero events and zero EVid, also return GRSP. OpCode 'F6' (246) Name ACDAT Title Accessory node data event Args / data NN,Byte1,Byte2,Byte3,Byte4,Byte5 Priority 3 Description Indicates an event from this node with 5 bytes of data. For example, this can be used to send the 40 bits of an RFID tag. There is no event number in order to allow space for 5 bytes of data in the packet, so there can only be one data event per node. OpCode 'F7' (247) Name ARDAT Title Accessory node data response Args / data NN,Byte1,Byte2,Byte3,Byte4,Byte5 Priority 3 Description Indicates a node data response. A response event is a reply to a status request (RQDAT) without producing a new data event. OpCode 'F8' (248) Name ASON3 Title Accessory Short ON Args / data NN,DNHigh_DNLow,Byte1,Byte2,Byte3 Priority 3 Description Indicates an ON event using the short event number of 2 LS bytes with three added data bytes. OpCode 'F9' (249) Name ASOF3 Title Accessory Short OFF Args / data NN,DNHigh_DNLow,Byte1,Byte2,Byte3 Priority 3 Description Indicates an OFF event using the short event number of 2 LS bytes with three added data bytes. OpCode 'FA' (250) Name DDES Title Device data event (short mode) Args / data DNHigh_DNLow,Byte1,Byte2,Byte3,Byte4,Byte5 Priority 3 Description Function is the same as F6 but uses device addressing so can relate data to a device attached to a node. e.g. one of several RFID readers attached to a single node. OpCode 'FB' (251) Name DDRS Title Device data response (short mode) Args / data DNHigh_DNLow,Byte1,Byte2,Byte3,Byte4,Byte5 Priority 3 Description The response to a request for data from a device. (0x5B) OpCode 'FC' (252) Name DDWS Title Write data Args / data DNHigh_DNLow,byte1,byte2,byte3,byte4,byte5 Priority 0 Description Used to write data to a device such as an RFID tag. For RC522 byte1 should be 0. OpCode 'FD' (253) Name ARSON3 Title Accessory Short Response Event Args / data NN,DNHigh_DNLow,Byte1,Byte2,Byte3 Priority 3 Description Indicates an ON response event with with three added data bytes. A response event is a reply to a status request (ASRQ) without producing an ON or OFF event. OpCode 'FE' (254) Name ARSOF3 Title Accessory Short Response Event Args / data NN,DNHigh_DNLow,Byte1,Byte2,Byte3 Priority 3 Description Indicates an OFF response event with with three added data bytes. A response event is a reply to a status request (ASRQ) without producing an ON or OFF event. OpCode 'FF' (255) Name EXTC6 Title Extended op-code with 6 data bytes Args / data ExtOpc,Byte1,Byte2,Byte3,Byte4,Byte5,Byte6 Priority 3 Description Used if the basic set of 32 OPCs is not enough. Allows an additional 256 OPCs"},{"location":"spec/#dcc-error-codes","title":"DCC Error codes","text":"<p>These are the DCC error codes listed in the VLCBOpcode.dcc_error_codes dictionary.</p> Error code Description '01' (1) Loco stack full '02' (2) Loco address taken '03' (3) Session not present '04' (4) Consist empty '05' (5) Loco not found '06' (6) CAN bus error '07' (7) Invalid request '08' (8) Session cancelled"},{"location":"spec/#cmderr-grsp-error-codes","title":"CMDERR / GRSP Error codes","text":"<p>These are the CMDERR / GRSP error codes listed in the VLCBOpcode.grsp_error_codes dictionary.</p> Error code Description '00' (0) OK '01' (1) Invalid command '02' (2) Not in learn mode '03' (3) Not in setup mode '04' (4) Too many events '05' (5) No event '06' (6) Invalid event variable index '07' (7) Invalid event '08' (8) Reserved '09' (9) Invalid parameter index '0A' (10) Invalid node variable index '0B' (11) Invalid event variable value '0C' (12) Invalid node variable value '0D' (13) Other in learn mode 'FA' (250) Invalid mode 'FB' (251) Invalid command parameter 'FC' (252) Invalid service 'FD' (253) Invalid diagnostic 'FE' (254) Unknown NVM type 'FF' (255) Reserved"}]}